<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>消息队列学习笔记 | 小Z成长录😀丶</title><meta name="keywords" content="工作技能,后端,消息队列"><meta name="author" content="十七"><meta name="copyright" content="十七"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#e8dfc4"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="消息队列学习笔记"><meta name="application-name" content="消息队列学习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#e8dfc4"><meta property="og:type" content="article"><meta property="og:title" content="消息队列学习笔记"><meta property="og:url" content="https://zc-zjy.github.io/2024/12/18/消息队列学习笔记/index.html"><meta property="og:site_name" content="小Z成长录😀丶"><meta property="og:description" content="一、消息队列基础介绍1、背景      有这么个场景，用户发送请求到支付服务，支付服务远程调用用户服务执行扣减余额业务，等扣减成功之后，支付服务再去更新支付状态，然后分别调用交易服务（更新订单状态）、通知服务（短信通知用户）和积分服务（增加用户积分），这里用户服务的扣减余额和支付服务的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://zc-zjy.github.io/img/page_background/cover_background_light.jpg"><meta property="article:author" content="十七"><meta property="article:tag" content="Java,Spring,软件开发技术,Vue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zc-zjy.github.io/img/page_background/cover_background_light.jpg"><meta name="description" content="一、消息队列基础介绍1、背景      有这么个场景，用户发送请求到支付服务，支付服务远程调用用户服务执行扣减余额业务，等扣减成功之后，支付服务再去更新支付状态，然后分别调用交易服务（更新订单状态）、通知服务（短信通知用户）和积分服务（增加用户积分），这里用户服务的扣减余额和支付服务的"><link rel="shortcut icon" href="/img/dog.png"><link rel="canonical" href="https://zc-zjy.github.io/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"小Z成长录😀丶","mode":"local","switchBtn":true,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["💢 励志成为技术大牛的一名小白"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: 十七","link":"链接: ","source":"来源: 小Z成长录😀丶","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小Z成长录😀丶',
  title: '消息队列学习笔记',
  postAI: '',
  pageFillDescription: '一、消息队列基础介绍, 二、RabbitMQ, 1、安装, 2、RabbitMQ后台管理系统使用, 3、Java代码中使用RabbitMQ, （1）知识介绍, （2）快速入门, （3）Work Queues, （4）Fanout交换机, （5）Direct交换机, （6）Topic交换机, （7）在代码中声明队列、交换机, （8）消息转换器, （9）消息队列在实际项目中的运用, 4、使用过程中遇到的问题, （1）确保消息发送成功, （2）确保MQ的可靠性, （3）确保消息接收成功, （4）延迟消息一消息队列基础介绍背景有这么个场景用户发送请求到支付服务支付服务远程调用用户服务执行扣减余额业务等扣减成功之后支付服务再去更新支付状态然后分别调用交易服务更新订单状态通知服务短信通知用户和积分服务增加用户积分这里用户服务的扣减余额和支付服务的更新支付状态是同步处理也就是说支付服务必须得等待用户服务完成扣减余额操作返回结果之后才能去更新支付状态但是其他服务和支付服务就属于异步处理为什么要异步因为如果同步的话每个服务都得等待前一个服务处理完才能处理这样耗时会很长性能会很差其他服务不用等待支付服务的处理结果上面的场景就可以使用消息队列而且使用消息队列后续如果还有新的需求需求新增加服务那我们可以不用去更改原来的代码直接去获取消息队列中的消息即可异步调用异步调用通常是基于消息通知的方式包含三个角色消息发送者投递消息的人就是原来的调用者消息接收者接收和处理消息的人就是原来的服务提供者消息代理管理暂存转发消息可以把它理解成微信服务器就如上面的场景在支付服务和交易服务通知服务积分服务之间加一层消息代理支付服务只管将消息发送给消息代理然后其他服务来监听消息代理技术框架已被淘汰二官网地址安装基于安装提示如果下不下来请点击链接下载本地镜像提取码然后将本地镜像加载到中通过命令加载加载之后想要删除包执行命令后台管理系统用户名后台管理系统密码挂载数据卷容器名后台管理系统端口服务端口指定网络后台运行镜像名其他安装方式查看官网后台管理系统使用访问地址输入配置的用户名和密码访问页面介绍页显示消息发送者和消息接收者只要连接了的服务都会在这里显示页显示消息通道页显示交换机页显示队列页管理用户的整体架构和核心概念交换机只能路由消息无法存储消息交换机只会路由消息给与自己绑定的队列因此队列必须与交换机绑定快速入门需求一需求在的后台管理系统中完成下列操作新建队列和向默认的交换机发送一条消息查看消息是否到达和步骤如上图所示分别添加和两个队列然后选中页点击交换机进入交换机详情页将两个队列与交换机建立关联如下图所示然后在该页面找到项在输入点击发送之后我们在页查看两个队列都收到消息了快速入门需求二需求数据隔离在的后台管理系统中完成下列操作新建一个用户为新建的用户创建一个测试不同之间的数据隔离现象步骤点击页点击右侧的选项点击输入用户名和密码是用户角色的意思这里选择超级管理员角色可以看到刚新建的用户是没有可以访问的的退出登录切换成刚创建的新用户我们点击页点击右侧选项点击创建一个新的虚拟机代码中使用知识介绍演示项目请点击访问下载在目录包是用于在应用程序之间传递业务消息的开放标准该协议与语言和平台无关更符合微服务中独立性的要求是基于协议定义的一套规范提供了模板来发送和接收消息它包含两部分其中是基础抽象是底层的默认实现快速入门需求打开上面演示项目演示项目中包括了两个服务消息接收者和消息发送者利用的后台管理系统创建队列在服务中利用直接向发送消息在服务中利用编写消费者监听队列注意该需求不涉及交换机是直接将消息发送到队列步骤创建队列这里不再做阐述在父工程中引入依赖这样和两个服务都可以使用依赖包含然后在每个服务中配置的服务端信息这样每个服务才能连接到的部署地址的服务端口要使用的虚拟机连接到的用户名连接到的密码在目录下创建单元测试包单元测试路径要与包下的路径保持一致创建测试类编写测试代码需要使用到类这个类包中已经提供了可以直接注入使用是提供的用于操作的工具类发送消息第一个参数队列名称第二个参数发送消息的内容启动之后可以去管理后台查看对应的队列中是否收到消息在服务中编写监听消息的消息接收者在目录下创建包在包下新建监听类监听队列的消息消息内容发送的时候是什么类型接收的时候就是什么类型监听到了的消息启动服务可以看到控制台输出了消息现在只要服务那边发送了消息服务这边就会监听到消息并且输出收到的消息任务模型简单来说就是让多个消费者绑定到一个队列共同消费队列中的消息注意队列中的消息只能由这些消费者中的一个接收比如队列中有一条消息这个队列绑定了三个消费者队列中的这条消息假如被消费者接收到了那么消费者和消费者是接收不到的需求在后台管理系统中创建一个队列名为在服务中定义测试方法发送条消息到在服务中定义两个消息监听者都监听队列注意该需求不涉及交换机是直接将消息发送到队列步骤创建队列这里不再做阐述基于快速入门中的项目继续做在服务中的类中添加两个方法注意实际项目中不可能写两个方法消费者监听到了的消息消费者监听到了的消息在服务中的测试类中添加测试的发送方法队列名发送条消息消息内容发送消息重启两个服务可以看到服务的控制台输出两个消费者分别接收到了条消息如果这两个消费者是在两个不同的服务中消费者的性能要比消费者的性能好这种情况下依然是每个消费者都处理条那么我们想实现能者多劳的效果也就是说让消费者处理更多的消息可以在配置文件中配置每次只能获取一条消息处理完成才能获取下一条消息总结模型的使用多个消费者绑定到一个队列可以加快消息处理速度同一条消息只会被一个消费者处理通过设置来控制消费者预取的消息数量处理完一条再处理下一条实现能者多劳交换机上面的案例都没有涉及到交换机从上面的案例可以看出消息可以直接发送到队列队列还具有存储消息的功能而交换机并没有存储消息的功能只有路由消息的功能那为什么还要有交换机呢我们可以从案例看出队列中的消息只要被消费者接收之后就没有该条消息了那么如果想实现这么一个场景这条消息想要被所有消费者都接收到广播的模式该怎么去实现这就得用到类型的交换机了交换机的作用主要是接收发送者发送的消息并将消息路由到与其绑定的队列而交换机就是可以实现一条消息所有消费者都能接收到即广播模式需求在后台管理系统中创建两个队列和在后台管理系统中创建交换机类型为并将两个队列与其绑定在服务中编写两个消费者方法分别监听和在服务中编写测试方法向发送消息步骤创建队列这里不再做阐述在服务中的类中添加两个方法注意实际项目中不可能写两个方法消费者监听到了的消息消费者监听到了的消息在服务中的测试类中添加测试的发送方法交换机名称发送消息第一个参数交换机名称第二个参数这里为和都行第三个参数消息内容交换机有这么个场景想要实现有些消息是多个消费者接收到有些消息只有个别消费者收到这种情况下就需要用到交换机了交换机会将接收到的消息根据规则路由到指定的队列即定向模式每一个队列在与交换机绑定时都设置一个一般将这个叫做发送者发送消息时指定消息的一般将这个叫做交换机将消息路由到与一致的队列需求在后台管理系统中创建两个队列和在后台管理系统中创建交换机类型为并将两个队列与其绑定绑定的时候在输入框处指定两个也就是输入的时候只能一个一个的输入去绑定指定两个在服务中编写两个消费者方法分别监听和在服务中编写测试方法向发送消息并指定步骤创建队列这里不再做阐述在服务中的类中添加两个方法注意实际项目中不可能写两个方法消费者监听到了的消息消费者监听到了的消息在服务中的测试类中添加测试的发送方法交换机名称发送消息第一个参数交换机名称第二个参数第三个参数消息内容说明如果第二个参数为那么和都能接收到消息如果第二个参数为那么只有能接收到消息如果第二个参数为那么只有能接收到消息如果第二个参数为那么和都不能接收到消息交换机交换机也是基于做消息路由的但是它的通常是多个单词的组合并且以分隔即主题模式队列与交换机指定时可以使用通配符个或多个单词一个单词比如六个队列与一个交换机绑定时设置的为队列为指中国的新闻消息队列为指中国的天气消息队列为指日本的新闻消息队列为指日本的天气消息队列为指中国的所有消息队列为指所有的新闻消息然后发送者发送消息指定的为所有中有的消费者都收到消息队列队列队列收到消息只有中有后跟一个单词的消费者能接收到消息队列队列收到消息和是接收不到消息的只有中有的消费者能接收到消息队列队列收到消息只有中有的消费者能接收到消息队列队列队列收到消息队列队列收到消息注意在创建交换机的时候类型为在代码中声明队列交换机说明之前所有案例的交换机队列都是在的后台管理系统中创建的实际开发中是不允许这么做都是在代码中创建的提供了几个类用来声明队列交换机及其绑定关系用于声明队列可以用工厂类构建用于声明交换机可以用工厂类构建用于声明队列和交换机的绑定关系可以用工厂类构建使用配置类声明声明一个类型的交换机并且创建队列与其绑定声明交换机参数交换机的名称声明第一个队列参数队列的名称绑定队列和交换机要和上面声明第一个队列方法名称保持一致要和上面声明交换机方法名称保持一致绑定哪个队列到哪个交换机如果有在方法后面调用方法指定如果得指定多个就得再新建一个方法略同理以相同的方式声明第二个队列并完成绑定同一个队列指定多个指定第一个为指定第二个为使用工厂类来创建队列交换机及其绑定关系声明交换机声明第一个队列绑定队列和交换机要和上面声明第一个队列方法名称保持一致要和上面声明交换机方法名称保持一致绑定哪个队列到哪个交换机指定多个同上面的方式一样注意上面的配置类都是写在消费者服务中的为什么因为发送者只关心发送消息将消息发到交换机或队列就行了而消费者需要去监听队列需要知道队列和哪个交换机绑定了上面绑定多个方法太繁琐推荐使用注解方式使用注解方式声明还提供了基于注解来声明队列和交换机消费者收到消息注意上面的注解方式也是写在消费者服务中的这个注解是使用在需要监听队列的方法上的消息转换器说明中默认消息是网络传输将消息内容对象转化成字节通过字节流进行传输默认的消息转换器是实现类基于的完成序列化它存在下列问题的序列化有完全风险序列化的消息太大序列化的消息可读性差是一串乱码修改默认消息转换器推荐使用序列化代替默认的序列化在和服务中引入依赖在和服务中配置消息转换器消息队列在实际项目中的运用具体查看学习笔记第五其他问题消息队列的使用使用过程中遇到的问题确保消息发送成功发送者重连机制针对消息发送者场景假如消息队列服务挂了或者由于网络波动可能会出现发送者连接失败的情况在消息发送服务配置设置的连接超时时间例如等了还没连上就认为连接超时开启超时重试机制默认是没有开启重连失败后的初始等待时间例如连接超时之后不会立刻去重连会等待再去重连失败后下次的等待时长倍数下次等待时长例如如果设置为第一次等待因为初始等待时间设置的是第二次等待第三次最大重连次数注意当网络不稳定的时候利用重试机制可以有效提高消息发送的成功率不过提供的重试机制是阻塞式的重试也即是说在重试期间发送消息服务会一直在重试直到重试成功或者达到重试最大次数才会继续往下执行业务会影响业务性能如果对于业务性能有要求建议禁用重试机制如果一定要使用请合理配置等待时长和重试次数也可以考虑使用异步线程来执行发送消息的代码发送者确认机制针对消息发送者有和两种确认机制是一起使用的开启确认机制后当发送消息服务给发送消息后会返回确认结果给发送消息服务返回结果有以下几种情况消息投递到了但是路由失败没有绑定队列或者代码错误此时会通过返回路由异常原因然后返回确认结果告知消息投递成功临时消息不需要持久化的消息投递到了并且入队成功返回告知投递成功持久消息投递到了并且入队完成持久化返回告知投递成功其他情况都会返回告知投递失败一般收到都需要重发消息收到的记录日志在发送消息服务的配置文件中配置有三种模式关闭机制默认同步阻塞等待的回执消息异步回调方式返回回执消息开启机制并设置类型开启机制默认为配置创建一个配置类设置回调函数交换机为消息本身异常异常然后配置需要去发送消息的代码处修改修改之前的代码发送消息发送的消息内容修改之后的代码设置回调函数消息投递成功消息投递失败这里内部处理时出现的异常不是投递消息失败的异常一般是不会出现的处理确认结果异常发送消息发送的消息内容确保的可靠性在默认情况下会将收到的消息保存在内存中以降低消息收发的延迟这样会导致两个问题一旦宕机内存中的消息会丢失内存空间有限当消费者故障或处理过慢时会导致消息积压引发阻塞因此可以使用数据持久化和来确保的可靠性推荐使用数据持久化实现数据持久化包括个方面每个都要做下面三个都设置之后哪怕服务重启都不会丢失消息交换机持久化在后台管理系统中创建交换机时在选项处选择代表交换机持久化而代表临时数据队列持久化同交换机持久化一样的操作消息持久化在后台管理系统中发送消息时有个选项代表临时消息代表持久化消息使用代码测试这个测试是用来测试消息设置成持久化之前和之后的性能对比注意测试之前需要先创建好持久交换机队列并且将配置文件中的关于确保消息发送成功的相关配置关闭步骤将下面先设置成临时消息测试一次再将设置成持久化消息测试一次可以查看后台管理系统的消息积压情况可知将设置成持久化之后性能会更好这里因为涉及到消息持久化所以我们需要自定义构建消息使用消息工厂类自定义消息方法设置消息体因为它需要字节码所以这里需要将字符串转换为字节码方法设置消息的投递模式默认是也就是临时消息代表持久化消息发送条消息交换机名字直接将消息存入磁盘不存内存之前的版本是先将消息存到内存中然后再根据消息设置如果设置了消息为持久化才将消息存入磁盘而从的版本开始就增加了的概念也就是惰性队列它的特征是接收到消息后直接存入磁盘不再存储到内存消费者要消费消息时才会从磁盘中读取并加载到内存可以提前缓存部分消息到内存最多条也就是说不管消息是临时消息还是持久化消息直接存入磁盘不存内存等消费者要使用消息时再从磁盘存入内存注意在版本后所有队列都是模式无法更改如果使用之前的版本需要使用的话在后台管理系统中创建队列的时候需要在选项处添加参数这里不需要在输入框输入可以直接点击下面的即可添加使用代码的方式添加要设置一个队列为惰性队列只需要在声明队列时指定属性为即可队列名字开启模式注解方式队列名字接收到消息推荐使用时都使用这个方式总结首先通过配置可以让交换机队列以及发送的消息都持久化这样队列中的消息会持久化到磁盘重启消息依然存在在版本引入了并且在版本后会将其设置成队列的默认模式这个模式会将所有消息都持久化开启持久化和生产者确认时只有在消息持久化完成后才会给生产者返回回执确保消息接收成功消费者确认机制针对消息接收服务消费者确认机制是为了确认消费者是否成功处理消息一共有三种场景返回表示消费者成功处理消息之后返回给服务告知服务自己成功处理消息让服务将该消息从队列中删除返回表示消费者处理消息时出现异常返回给服务告知服务不要删除消息将消息重新投递给自己处理直到成功返回表示消费者处理消息时出现异常并告知服务拒绝该消息处理让服务将该消息从队列中删除注意上面的三种场景都是消费者处理完之后才能返回不是刚接收到消息就返回因为已经实现了消息确认功能所以只需要在配置文件中配置处理方式有三种方式不处理即消息投递给消费者后不管消息是否处理成功服务都会将消息从队列中删除默认方式手动模式需要自己在业务代码中调用发送或这种方式可能存在业务入侵自动模式利用实现了功能自动返回不同的结果在消息接收服务配置针对上面消费者确认机制中的第二种场景返回如果消费者即消息接收服务一直处理失败服务就会一直投递这是不可取的会让服务有很大压力所以我们还需要设置失败重试机制在消息接收服务配置开启消费者失败重试默认时关闭的初始的失败等待时长为下次失败的等待时长倍数下次等待时长最大重试次数是否无状态无状态有状态如果业务中包含事务这里改为注意如果设置为表示有事务那么属性将失效因为涉及到事务所以不能重试如果设置为表示无事务那么属性生效可以重试这里介绍下重试策略在开启重试模式后重试次数耗尽如果消息依然存在则需要有接口来处理它有三种不同实现重试耗尽后直接拒绝消息丢弃消息不再重试默认方式重试耗尽后返回消息重新入队等待消费重试耗尽后将失败消息投递到指定的交换机将重试策略修改为在消息接收服务创建配置类创建定义交换机交换机名字创建定义队列队列名字绑定交换机和队列路由键名字重试策略交换机名字路由键名字现在还有这么一个问题就是消费者重复处理问题比如消费者处理完消息后要返回状态给服务此时因为网络原因服务没有收到消费者的恢复服务就会将消息重新投递给消费者导致消费者重复处理消息解决方法一唯一消息给每个消息都设置一个唯一利用区分是否是重复消息每一条消息都生成一个唯一的与消息一起投递给消费者消费者接收到消息后处理自己的业务业务处理成功后将消息保存到数据库如果下次又收到相同消息去数据库查询判断是否存在存在则为重复消息放弃处理在消息发送服务消息提供者修改消息转换器让消息转换器帮我们生成消息开启消息生成在消息接收服务消费者接收消息之前是消息发送服务发送的是什么类型的消息消息接收服务接收消息就是什么类型的消息现在修改为使用类来接收消息获取消息获取消息内容消息消息内容解决方法二基于业务判断在服务第一次投递给消费者处理之前先查询数据库判断消息是否已经处理过如果处理过则直接返回不再处理具体例子查看学习笔记第五点其他问题的第点延迟消息使用场景保证服务和服务一致性通常是基于消息队列由服务通知服务去保证一致性但是因为某个原因导致这种方案就是不能成功不能保证一致性所以此时就必须有一个兜底方案就是消息延迟延迟消息发送者发送消息时指定一个时间消费者不会立刻收到消息而是在指定时间之后才收到消息就比如通常情况下都是服务通知服务延迟消息就是有一个专门接收延迟消息的消息队列服务通知服务的同时也发一个延迟消息给这个消息队列设置一个延迟时间比如分钟然后服务等待服务回执分钟如果分钟之后还是没有服务的回执那服务就主动去远程查询调用服务实现方式死信交换机延迟消息插件死信交换机解释当一个队列中的消息满足下列情况之一时就会成为死信消费者使用或返回消费失败并且消息被设置成不想重新投递消息的参数设置为消息是一个过期消息达到了队列或消息本身设置的过期时间超时无人消费要投递的队列消息堆积满了最早的消息可能成为死信默认情况下消息成为死信会被删除如果队列通过属性指定了一个交换机那么该队列中的消息成为死信后就会投递到被指定的这个交换机中这个交换机就是死信交换机所以死信交换机就是专门用来接收死信的交换机现在使用死信交换机来做延迟消息下图所示注意如果使用了那么死信交换机死信队列要和上面交换机队列的保持一致代码实现定义一个死信交换机和死信队列接收到死信队列的消息不能使用上面的方法来定义交换机队列因为使用上面的方法就会有消费者监听需要使用传统的方式定义一个普通交换机普通队列并设置死信交换机创建定义交换机创建定义队列并设置属性绑定一个死信交换机绑定交换机和队列发送消息第一个参数交换机名字第二个参数路由键名字第三个参数消息内容第四个参数是消息后置处理器可以用来对消息进行处理比如设置消息过期时间设置消息过期时间延迟消息插件插件因为上面死信交换机实现比较繁琐需要创建定义多个交换机和队列容易出错所以可以使用延迟消息插件这个插件可以将普通交换机改造为支持延迟消息功能的交换机当消息投递到交换机后可以暂存一定时间到期后再投递到队列关于插件下载请点击插件版本要和版本保持一致比如是那么插件也要安装插件基于安装如果是基于安装的才看这个先查看的插件目录对应的数据卷是数据卷的名字如果挂载的数据卷名字不是这个需要根据自己的数据卷名字修改可以使用查看所有数据卷列表可以看到属性表示插件目录被挂载到了这个目录上传下载下来的插件到该目录然后执行命令安装插件后面的是容器的名字根据自己的容器名修改使用通过注解方式属性设为表示是延迟交换机队列名字交换机名字接收到延迟队列的消息通过代码方式交换机名字设置属性为持久化发送消息是需要通过消息头来设置过期时间第一个参数交换机名字第二个参数路由键名字第三个参数消息内容第四个参数是消息后置处理器可以用来对消息进行处理比如设置消息过期时间设置消息过期时间具体使用延迟消息插件示例请查看学习笔记中其他问题章节的第点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-07 12:21:39',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#e8dfc4')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar/loading.gif"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">小Z成长录😀丶</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "city": "CN101290101",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/reward/zjyzanshang.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/zjyzanshang.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/reward/zjyzfb.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/zjyzfb.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Camunda/" style="font-size: 1.05rem;">Camunda<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 1.05rem;">ElasticSearch<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/IntelliJ-IDEA-2020-3-3-x64%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/" style="font-size: 1.05rem;">IntelliJ IDEA 2020.3.3 x64激活方法<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>14</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Maven/" style="font-size: 1.05rem;">Maven<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 1.05rem;">Mybatis<sup>1</sup></a><a href="/tags/MybatisPlus/" style="font-size: 1.05rem;">MybatisPlus<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 1.05rem;">Mysql<sup>1</sup></a><a href="/tags/Postgresql/" style="font-size: 1.05rem;">Postgresql<sup>1</sup></a><a href="/tags/Postman/" style="font-size: 1.05rem;">Postman<sup>1</sup></a><a href="/tags/SVN/" style="font-size: 1.05rem;">SVN<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>7</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>1</sup></a><a href="/tags/navicat/" style="font-size: 1.05rem;">navicat<sup>1</sup></a><a href="/tags/%E4%B9%A6%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">书本知识<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>3</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>25</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" style="font-size: 1.05rem;">工作技能<sup>39</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/" style="font-size: 1.05rem;">工作流<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>3</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>3</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">测试工具<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.05rem;">消息队列<sup>1</sup></a><a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" style="font-size: 1.05rem;">版本控制<sup>2</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" itemprop="url">工作技能</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>工作技能</span></a><a class="article-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>后端</span></a><a class="article-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>消息队列</span></a></span></div></div><h1 class="post-title" itemprop="name headline">消息队列学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-18T01:51:12.000Z" title="发表于 2024-12-18 09:51:12">2024-12-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-07T04:21:39.121Z" title="更新于 2025-01-07 12:21:39">2025-01-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="消息队列学习笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为昆明"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>昆明</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/page_background/cover_background_light.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://zc-zjy.github.io/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" itemprop="url">工作技能</a><a href="/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" tabindex="-1" itemprop="url">工作技能</a><a href="/tags/%E5%90%8E%E7%AB%AF/" tabindex="-1" itemprop="url">后端</a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" tabindex="-1" itemprop="url">消息队列</a><h1 id="CrawlerTitle" itemprop="name headline">消息队列学习笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">十七</span><time itemprop="dateCreated datePublished" datetime="2024-12-18T01:51:12.000Z" title="发表于 2024-12-18 09:51:12">2024-12-18</time><time itemprop="dateCreated datePublished" datetime="2025-01-07T04:21:39.121Z" title="更新于 2025-01-07 12:21:39">2025-01-07</time></header><br/>


<hr>
<br/>


<h1 id="一、消息队列基础介绍"><a href="#一、消息队列基础介绍" class="headerlink" title="一、消息队列基础介绍"></a>一、消息队列基础介绍</h1><p>1、背景  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="">  
<p>有这么个场景，用户发送请求到<code>支付服务</code>，<code>支付服务</code>远程调用<code>用户服务</code>执行扣减余额业务，等扣减成功之后，<code>支付服务</code>再去更新支付状态，然后分别调用<code>交易服务</code>（更新订单状态）、<code>通知服务</code>（短信通知用户）和<code>积分服务</code>（增加用户积分），这里<code>用户服务</code>的扣减余额和<code>支付服务</code>的更新支付状态是同步处理，也就是说<code>支付服务</code>必须得等待<code>用户服务</code>完成扣减余额操作，返回结果之后才能去更新支付状态，但是其他服务和<code>支付服务</code>就属于异步处理（为什么要异步？因为如果同步的话，每个服务都得等待前一个服务处理完才能处理，这样耗时会很长，性能会很差），其他服务不用等待<code>支付服务</code>的处理结果。<br>上面的场景就可以使用消息队列，而且使用消息队列，后续如果还有新的需求，需求新增加服务，那我们可以不用去更改原来的代码，直接去获取消息队列中的消息即可。  </p>
<p>2、异步调用<br>异步调用通常是基于消息通知的方式，包含三个角色：<br>（1）消息发送者：投递消息的人，就是原来的调用者；<br>（2）消息接收者：接收和处理消息的人，就是原来的服务提供者；<br>（3）消息代理：管理、暂存、转发消息，可以把它理解成微信服务器。  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="">  
<p>就如上面的场景，在<code>支付服务</code>和<code>交易服务</code>、<code>通知服务</code>、<code>积分服务</code>之间加一层<code>消息代理</code>，<code>支付服务</code>只管将消息发送给<code>消息代理</code>，然后其他服务来监听<code>消息代理</code>。  </p>
<p>3、技术框架  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="">  
<p><code>ActiveMQ</code>已被淘汰。  </p>
<br/>


<hr>
<br/>


<h1 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h1><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">官网地址</a>  </p>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>1、基于Docker安装<br>提示：如果docker下不下来，请点击<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1sOkAciC9WvifdOWTc7fBQw?pwd=frxr">链接</a>下载本地镜像，提取码：<code>frxr</code>，然后将本地镜像<code>mq.tar</code>加载到docker中，通过<code>docker load -i mq.tar</code>命令加载，加载之后想要删除tar包，执行命令<code>rm -rf mq.tar</code>。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">  -e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">  -v mq-plugins:/plugins \</span><br><span class="line">  --name mq \</span><br><span class="line">  -p 15672:15672 \</span><br><span class="line">  -p 5672:5672 \</span><br><span class="line">  --network net\</span><br><span class="line">  -d \</span><br><span class="line">  rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>
<p><code>-e RABBITMQ_DEFAULT_USER=admin</code>：RabbitMQ后台管理系统用户名；<br><code>-e RABBITMQ_DEFAULT_PASS=admin</code>：RabbitMQ后台管理系统密码；<br><code>-v mq-plugins:/plugins</code>：挂载数据卷；<br><code>--name mq</code>：容器名；<br><code>-p 15672:15672</code>：RabbitMQ后台管理系统端口；<br><code>-p 5672:5672</code>：RabbitMQ服务端口；<br><code>--network net</code>：指定网络；<br><code>-d</code>：后台运行；<br><code>rabbitmq:3.8-management</code>：镜像名。<br>其他安装方式查看官网。  </p>
<h3 id="2、RabbitMQ后台管理系统使用"><a href="#2、RabbitMQ后台管理系统使用" class="headerlink" title="2、RabbitMQ后台管理系统使用"></a>2、RabbitMQ后台管理系统使用</h3><p>1、访问地址<br><code>http://ip:15672</code>，输入配置的用户名和密码访问。  </p>
<p>2、页面介绍<br><code>Connections</code>Tab页：显示消息发送者和消息接收者，只要连接了RabbitMQ的服务都会在这里显示。<br><code>Channels</code>Tab页：显示消息通道。<br><code>Exchanges</code>Tab页：显示交换机。<br><code>Queues</code>Tab页：显示队列。<br><code>Admin</code>Tab页：管理用户。  </p>
<p>3、RabbitMQ的整体架构和核心概念  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="">  
<p>（1）交换机（exchange）只能路由消息，无法存储消息。<br>（2）交换机（exchange）只会路由消息给与自己绑定的队列，因此队列必须与交换机绑定。  </p>
<p>4、快速入门需求一<br>（1）需求  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class="line"><span class="number">1</span>、新建队列 hello<span class="selector-class">.queue1</span> 和 hello.queue2；</span><br><span class="line"><span class="number">2</span>、向默认的 amp<span class="selector-class">.fanout</span> 交换机发送一条消息；</span><br><span class="line"><span class="number">3</span>、查看消息是否到达 hello<span class="selector-class">.queue1</span> 和 hello.queue2。</span><br></pre></td></tr></table></figure>
<p>（2）步骤  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="">  
<p>如上图所示，分别添加hello.queue1和hello.queue2两个队列。<br>然后选中<code>Exchanges</code>Tab页，点击<code>amp.fanout</code>交换机进入交换机详情页，将两个队列与交换机建立关联，如下图所示。  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="">  
<p>然后在该页面找到<code>Publish message</code>项，在<code>Payload</code>输入hello，mq！，点击发送之后，我们在<code>Queues</code>Tab页查看，两个队列都收到消息了。  </p>
<p>5、快速入门需求二<br>（1）需求（数据隔离）  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class="line"><span class="number">1</span>、新建一个用户；</span><br><span class="line"><span class="number">2</span>、为新建的用户创建一个 <span class="keyword">virtual</span> host；</span><br><span class="line"><span class="number">3</span>、测试不同 <span class="keyword">virtual</span> host 之间的数据隔离现象。</span><br></pre></td></tr></table></figure>
<p>（2）步骤<br>点击<code>Admin</code>Tab页，点击右侧的<code>Users</code>选项，点击<code>Add a user</code>，输入用户名和密码，Tags是用户角色的意思，这里选择超级管理员角色Admin。<br>可以看到刚新建的用户是没有可以访问的virtual host的，退出登录，切换成刚创建的新用户。<br>我们点击<code>Admin</code>Tab页，点击右侧<code>Virtual Hosts</code>选项，点击<code>Add a new virtual host</code>，创建一个新的虚拟机。  </p>
<h3 id="3、Java代码中使用RabbitMQ"><a href="#3、Java代码中使用RabbitMQ" class="headerlink" title="3、Java代码中使用RabbitMQ"></a>3、Java代码中使用RabbitMQ</h3><h4 id="（1）知识介绍"><a href="#（1）知识介绍" class="headerlink" title="（1）知识介绍"></a>（1）知识介绍</h4><p>演示项目<a target="_blank" rel="noopener" href="https://gitee.com/zuo-junyuan/microservice-learning-notes">请点击访问下载</a>，在mq目录<code>mq-demo.zip</code>包。<br><code>AMQP</code>（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准，该协议与语言和平台无关，更符合微服务中独立性的要求。<br><code>Spring AMQP</code>是基于<code>AMQP</code>协议定义的一套API规范，提供了模板来发送和接收消息，它包含两部分，其中<code>spring-amqp</code>是基础抽象，<code>spring-rabbit</code>是底层的默认实现。  </p>
<h4 id="（2）快速入门"><a href="#（2）快速入门" class="headerlink" title="（2）快速入门"></a>（2）快速入门</h4><p>（1）需求<br>打开上面演示项目，演示项目中包括了两个服务<code>consumer</code>（消息接收者）和<code>publisher</code>（消息发送者）。  </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、利用RabbitMQ的后台管理系统创建队列 simple.queue；</span><br><span class="line"><span class="number">2</span>、在publisher服务中，利用SpringAMQP直接向simple.queue发送消息；</span><br><span class="line"><span class="number">3</span>、在consumer服务中，利用SpringAMQP编写消费者，监听simple.queue队列。</span><br><span class="line">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>
<p>（2）步骤<br>创建队列这里不再做阐述。<br>在父工程中引入<code>spring-amqp</code>依赖，这样publisher和consumer两个服务都可以使用：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在每个服务中配置MQ的服务端信息，这样每个服务才能连接到RabbitMQ：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># RabbitMQ的部署ip地址</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># RabbitMQ的服务端口</span></span><br><span class="line">	<span class="attr">virtual-host:</span> <span class="string">/mq</span> <span class="comment"># 要使用的虚拟机</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">admin</span> <span class="comment"># 连接到RabbitMQ的用户名</span></span><br><span class="line">	<span class="attr">password:</span> <span class="string">admin</span> <span class="comment"># 连接到RabbitMQ的密码</span></span><br></pre></td></tr></table></figure>
<p>在<code>test/java</code>目录下创建<code>com.itheima.publisher</code>单元测试包（单元测试路径要与main包下的路径保持一致），创建<code>SpringAmqpTest</code>测试类，编写测试代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 需要使用到RabbitTemplate类，这个类amqp包中已经提供了，可以直接注入使用</span></span><br><span class="line"><span class="comment">	 * RabbitTemplate是SpringAMQP提供的用于操作RabbitMQ的工具类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1、发送消息</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 第一个参数：队列名称</span></span><br><span class="line"><span class="comment">		 * 第二个参数：发送消息的内容</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;hello, spring amqp!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动之后，可以去RabbitMQ管理后台查看对应的队列中是否收到消息。<br>在<code>consumer</code>服务中编写监听消息的消息接收者，在main&#x2F;java目录下创建mq包，在mq包下新建SpringRabbitListener监听类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 监听simple.queue队列的消息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> msg 消息内容，发送的时候是什么类型，接收的时候就是什么类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;spring amqp 监听到了simple.queue的消息：&quot;</span> + msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动<code>consumer</code>服务，可以看到控制台输出了消息。现在只要<code>publisher</code>服务那边发送了消息，<code>consumer</code>服务这边就会监听到消息，并且输出收到的消息。  </p>
<h4 id="（3）Work-Queues"><a href="#（3）Work-Queues" class="headerlink" title="（3）Work Queues"></a>（3）Work Queues</h4><p><code>Work Queues</code>：任务模型，简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。注意：队列中的消息只能由这些消费者中的一个接收，比如：队列中有一条消息，这个队列绑定了三个消费者，队列中的这条消息假如被消费者2接收到了，那么消费者1和消费者3是接收不到的。<br>1、需求  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、在RabbitMQ后台管理系统中创建一个队列，名为 work.queue；</span><br><span class="line"><span class="number">2</span>、在 publisher 服务中定义测试方法，发送<span class="number">50</span>条消息到 work.queue；</span><br><span class="line"><span class="number">3</span>、在 consumer 服务中定义两个消息监听者，都监听 work.queue 队列。</span><br><span class="line">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>
<p>2、步骤<br>创建队列这里不再做阐述。<br>基于<code>快速入门</code>中的项目继续做。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueueOne</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者1监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueueTwo</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者2监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 队列名</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送50条消息</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">50</span>;i ++) &#123;</span><br><span class="line">		<span class="comment">// 消息内容</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp! &quot;</span> + i;</span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		rabbitTemplate.convertAndSend(queueName, msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启两个服务，可以看到<code>consumer</code>服务的控制台输出，两个消费者分别接收到了25条消息。<br>如果这两个消费者是在两个不同的服务中，消费者1的性能要比消费者2的性能好，这种情况下依然是每个消费者都处理25条。<br>那么我们想实现“能者多劳”的效果，也就是说让消费者1处理更多的消息，可以在配置文件中配置：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="attr">listener:</span> </span><br><span class="line">	  <span class="attr">simple:</span> </span><br><span class="line">	    <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一条消息</span></span><br></pre></td></tr></table></figure>
<p>3、总结：<code>Work</code>模型的使用  </p>
<ol>
<li>多个消费者绑定到一个队列，可以加快消息处理速度；  </li>
<li>同一条消息只会被一个消费者处理；  </li>
<li>通过设置<code>prefetch</code>来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳。</li>
</ol>
<h4 id="（4）Fanout交换机"><a href="#（4）Fanout交换机" class="headerlink" title="（4）Fanout交换机"></a>（4）Fanout交换机</h4><p>上面的案例都没有涉及到<code>交换机</code>，从上面的案例可以看出，消息可以直接发送到队列，队列还具有存储消息的功能，而交换机并没有存储消息的功能，只有路由消息的功能，那为什么还要有交换机呢？<br>我们可以从<code>Work Queues</code>案例看出，队列中的消息只要被消费者接收之后，就没有该条消息了。那么如果想实现这么一个场景：这条消息想要被所有消费者都接收到（广播的模式），该怎么去实现？这就得用到<code>Fanout</code>类型的交换机了。<br><code>交换机</code>的作用：主要是接收发送者发送的消息，并将消息路由到与其绑定的队列，而<code>Fanout交换机</code>就是可以实现一条消息，所有消费者都能接收到，即<code>广播模式</code>。<br>1、需求  </p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、在<span class="type">RabbitMQ</span>后台管理系统中，创建两个队列 fanout.queue1 和 fanout.queue2；</span><br><span class="line"><span class="number">2</span>、在<span class="type">RabbitMQ</span>后台管理系统中，创建交换机 fanout.exchange，类型<span class="keyword">type</span>为 fanout，并将两个队列与其绑定；</span><br><span class="line"><span class="number">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2；</span><br><span class="line"><span class="number">4</span>、在 publisher 服务中，编写测试方法，向 fanout.exchange发送消息。</span><br></pre></td></tr></table></figure>
<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueueOne</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者1监听到了fanout.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueueTwo</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者2监听到了fanout.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout.exchange&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 第一个参数：交换机名称</span></span><br><span class="line"><span class="comment">	 * 第二个参数：这里为null和&quot;&quot;都行</span></span><br><span class="line"><span class="comment">	 * 第三个参数：消息内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hello,exange fanout!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）Direct交换机"><a href="#（5）Direct交换机" class="headerlink" title="（5）Direct交换机"></a>（5）Direct交换机</h4><p>有这么个场景：想要实现有些消息是多个消费者接收到，有些消息只有个别消费者收到，这种情况下，就需要用到<code>Direct交换机</code>了。<br><code>Direct交换机</code>：会将接收到的消息根据规则路由到指定的队列，即<code>定向模式</code>。<br>（1）每一个队列在与交换机绑定时，都设置一个key（一般将这个key叫做<code>BindingKey</code>）；<br>（2）发送者发送消息时，指定消息的key（一般将这个key叫做<code>RoutingKey</code>）；<br>（3）交换机将消息路由到<code>BindingKey</code>与<code>RoutingKey</code>一致的队列。<br>1、需求  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、在RabbitMQ后台管理系统中，创建两个队列 <span class="built_in">direct</span>.queue1 和 <span class="built_in">direct</span>.queue2；</span><br><span class="line"><span class="number">2</span>、在RabbitMQ后台管理系统中，创建交换机 <span class="built_in">direct</span>.exchange，类型type为 <span class="built_in">direct</span>，并将两个队列与其绑定，绑定的时候在RoutingKey输入框处<span class="built_in">direct</span>.queue1指定red、blue两个<span class="built_in">key</span>，也就是BindingKey（输入的时候只能一个一个的输入去绑定），<span class="built_in">direct</span>.queue2指定red、yellow两个<span class="built_in">key</span>；</span><br><span class="line"><span class="number">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 <span class="built_in">direct</span>.queue1 和 <span class="built_in">direct</span>.queue2；</span><br><span class="line"><span class="number">4</span>、在 publisher 服务中，编写测试方法，向 <span class="built_in">direct</span>.exchange发送消息，并指定RoutingKey。</span><br></pre></td></tr></table></figure>
<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueueOne</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者1监听到了direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueueTwo</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;消费者2监听到了direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;direct.exchange&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 第一个参数：交换机名称</span></span><br><span class="line"><span class="comment">	 * 第二个参数：RoutingKey</span></span><br><span class="line"><span class="comment">	 * 第三个参数：消息内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;hello,exange direct!&quot;</span>);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 说明：</span></span><br><span class="line"><span class="comment">	 * 1、如果第二个参数RoutingKey为red，那么direct.queue1和direct.queue2都能接收到消息；</span></span><br><span class="line"><span class="comment">	 * 2、如果第二个参数RoutingKey为blue，那么只有direct.queue1能接收到消息；</span></span><br><span class="line"><span class="comment">	 * 3、如果第二个参数RoutingKey为yellow，那么只有direct.queue2能接收到消息；</span></span><br><span class="line"><span class="comment">	 * 4、如果第二个参数RoutingKey为green，那么direct.queue1和direct.queue2都不能接收到消息。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）Topic交换机"><a href="#（6）Topic交换机" class="headerlink" title="（6）Topic交换机"></a>（6）Topic交换机</h4><p><code>Topic交换机</code>：也是基于RoutingKey做消息路由的，但是它的RoutingKey通常是多个单词的组合，并且以<code>.</code>分隔，即<code>主题模式</code>。<br>队列与交换机指定BindingKey时可以使用通配符：<code>#</code>（0个或多个单词）、<code>*</code>（一个单词）。<br>比如：<br>六个队列与一个交换机绑定时，设置的<code>BindingKey</code>为：<br>队列1为<code>china.news</code>：指中国的新闻消息；<br>队列2为<code>china.weather</code>：指中国的天气消息；<br>队列3为<code>japan.news</code>：指日本的新闻消息；<br>队列4为<code>japan.weather</code>：指日本的天气消息；<br>队列5为<code>china.#</code>：指中国的所有消息；<br>队列6为<code>#.news</code>：指所有的新闻消息。<br>然后发送者发送消息指定的<code>RoutingKey</code>为：<br><code>china.#</code>：所有<code>BindingKey</code>中有<code>china</code>的消费者都收到消息，队列1、队列2、队列5收到消息；<br><code>japan.*</code>：只有<code>BindingKey</code>中有<code>japan</code>后跟一个单词的消费者能接收到消息，队列3、队列4收到消息（<code>japan</code>和<code>japan.xxx.xxx</code>是接收不到消息的）；<br><code>#.weather</code>：只有<code>BindingKey</code>中有<code>weather</code>的消费者能接收到消息，队列2、队列4收到消息；<br><code>china.news</code>：只有<code>BindingKey</code>中有<code>china.news</code>的消费者能接收到消息，队列1、队列5、队列6收到消息；<br><code>china.weather</code>：队列2、队列5收到消息。<br>注意：在创建交换机的时候，类型type为<code>topic</code>。  </p>
<h4 id="（7）在代码中声明队列、交换机"><a href="#（7）在代码中声明队列、交换机" class="headerlink" title="（7）在代码中声明队列、交换机"></a>（7）在代码中声明队列、交换机</h4><p>1、说明<br>之前所有案例的交换机、队列都是在RabbitMQ的后台管理系统中创建的，实际开发中是不允许这么做，都是在代码中创建的。<br><code>SpringAMQP</code>提供了几个类，用来声明队列、交换机及其绑定关系：<br>（1）<code>Queue</code>：用于声明队列，可以用工厂类<code>QueueBuilder</code>构建；<br>（2）<code>Exchange</code>：用于声明交换机，可以用工厂类<code>ExchangeBuilder</code>构建；<br>（3）<code>Binding</code>：用于声明队列和交换机的绑定关系，可以用工厂类<code>BindingBuilder</code>构建。  </p>
<p>2、使用配置类声明<br>声明一个<code>Fanout</code>类型的交换机，并且创建队列与其绑定：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">	<span class="comment">// 声明 FanoutExchange 交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 参数：交换机的名称</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout.exchange&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 声明第一个队列</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">fanoutQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 参数：队列的名称</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 绑定队列1和交换机</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">bindingQueueOne</span><span class="params">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="line">		<span class="comment">// 绑定哪个队列到哪个交换机</span></span><br><span class="line">		<span class="comment">// 如果有 BindingKey 在to方法后面调用with方法指定，如果得指定多个 BindingKey 就得再新建一个方法</span></span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...略，同理，以相同的方式声明第二个队列并完成绑定</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 同一个队列指定多个 BindingKey：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">	 * public Binding bindingQueueOneRed(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class="line"><span class="comment">	 *   // 指定 第一个 BindingKey 为 Red</span></span><br><span class="line"><span class="comment">	 *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;red&quot;);</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">	 * public Binding bindingQueueOneBlue(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class="line"><span class="comment">	 *   // 指定 第二个 BindingKey 为 Blue</span></span><br><span class="line"><span class="comment">	 *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;blue&quot;);</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用工厂类来创建队列、交换机及其绑定关系：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">	<span class="comment">// 声明 FanoutExchange 交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;fanout.exchange&quot;</span>).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 声明第一个队列</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">fanoutQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout.queue1&quot;</span>).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 绑定队列1和交换机</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">bindingQueueOne</span><span class="params">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="line">		<span class="comment">// 绑定哪个队列到哪个交换机</span></span><br><span class="line">		<span class="comment">// 指定多个 BindingKey 同上面的方式一样</span></span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上面的配置类都是写在<code>consumer</code>消费者服务中的！<br>为什么？<br>因为发送者只关心发送消息，将消息发到交换机或队列就行了，而消费者需要去监听队列，需要知道队列和哪个交换机绑定了。<br>上面绑定多个BindingKey方法太繁琐，推荐使用注解方式。  </p>
<p>3、使用注解方式声明<br><code>SpringAMQP</code>还提供了基于<code>@RabbitListener</code>注解来声明队列和交换机：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(</span></span><br><span class="line"><span class="meta">  bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">	exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">	key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueueOne</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;消费者1收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上面的注解方式也是写在<code>consumer</code>消费者服务中的，这个注解是使用在需要监听队列的方法上的！  </p>
<h4 id="（8）消息转换器"><a href="#（8）消息转换器" class="headerlink" title="（8）消息转换器"></a>（8）消息转换器</h4><p>1、说明<br><code>SpringAMQP</code>中默认消息是网络传输，将消息内容（对象）转化成字节，通过字节流进行传输，默认的消息转换器是<code>SimpleMessageConverter</code>实现类，基于JDK的<code>ObjectOutputStream</code>完成序列化。<br>它存在下列问题：<br>（1）JDK的序列化有完全风险；<br>（2）JDK序列化的消息太大；<br>（3）JDK序列化的消息可读性差，是一串乱码。  </p>
<p>2、修改默认消息转换器<br>推荐使用JSON序列化代替默认的JDK序列化，在publisher和consumer服务中引入jackson依赖：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在publisher和consumer服务中配置MessageConverter消息转换器：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（9）消息队列在实际项目中的运用"><a href="#（9）消息队列在实际项目中的运用" class="headerlink" title="（9）消息队列在实际项目中的运用"></a>（9）消息队列在实际项目中的运用</h4><p>具体查看<a href="/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-53">SpringCloud学习笔记第五、其他问题消息队列的使用</a>。  </p>
<h3 id="4、使用过程中遇到的问题"><a href="#4、使用过程中遇到的问题" class="headerlink" title="4、使用过程中遇到的问题"></a>4、使用过程中遇到的问题</h3><h4 id="（1）确保消息发送成功"><a href="#（1）确保消息发送成功" class="headerlink" title="（1）确保消息发送成功"></a>（1）确保消息发送成功</h4><p>1、发送者重连机制（针对消息发送者）<br>场景：假如MQ消息队列服务挂了或者由于网络波动，可能会出现发送者连接MQ失败的情况。<br>在消息发送服务配置：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间，例如：等了1s还没连上就认为连接超时</span></span><br><span class="line">	<span class="attr">template:</span> </span><br><span class="line">	  <span class="attr">retry:</span> </span><br><span class="line">	    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制，默认是没有开启</span></span><br><span class="line">		<span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 重连失败后的初始等待时间，例如：连接超时之后不会立刻去重连，会等待1000ms再去重连</span></span><br><span class="line">		<span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier，例如：如果设置为2，第一次等待1000ms（因为初始等待时间设置的是1000ms），第二次等待2000ms，第三次4000ms</span></span><br><span class="line">		<span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重连次数</span></span><br></pre></td></tr></table></figure>
<p>注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率，不过SpringAMQP提供的重试机制是阻塞式的重试，也即是说在重试期间，发送消息服务会一直在重试，直到重试成功或者达到重试最大次数，才会继续往下执行业务，会影响业务性能。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，也可以考虑使用异步线程来执行发送消息的代码。  </p>
<p>2、发送者确认机制（针对消息发送者）<br>SpringAMQP有<code>Publisher Confirm</code>和<code>Publisher Return</code>两种确认机制（是一起使用的）。开启确认机制后，当发送消息服务给MQ发送消息后，MQ会返回确认结果给发送消息服务，返回结果有以下几种情况：<br>（1）消息投递到了MQ，但是路由失败（没有绑定队列或者代码错误）。此时会通过PublisherReturn返回路由异常原因，然后返回ACK（确认结果），告知消息投递成功；<br>（2）临时消息（不需要持久化的消息）投递到了MQ，并且入队成功，返回ACK，告知投递成功；<br>（3）持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功；<br>（4）其他情况都会返回NACK，告知投递失败。<br>一般收到NACK都需要重发消息，收到ACK的记录日志。<br>在发送消息服务的配置文件中配置：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="comment"># publisher-confirm-type有三种模式：</span></span><br><span class="line">	<span class="comment"># 1. none：关闭confirm机制，默认</span></span><br><span class="line">	<span class="comment"># 2. simple：同步阻塞等待MQ的回执消息</span></span><br><span class="line">	<span class="comment"># 3. correlated：MQ异步回调方式返回回执消息</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">	<span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制，默认为false</span></span><br></pre></td></tr></table></figure>
<p>配置<code>Publisher Return</code>，创建一个MQ配置类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 设置Publisher Return回调函数</span></span><br><span class="line">		rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;交换机为：&quot;</span> + returned.getExchange());</span><br><span class="line">				System.out.println(<span class="string">&quot;routingKey：&quot;</span> + returned.getRoutingKey());</span><br><span class="line">				System.out.println(<span class="string">&quot;消息本身message：&quot;</span> + returned.getMessage());</span><br><span class="line">				System.out.println(<span class="string">&quot;异常code：&quot;</span> + returned.getReplyCode());</span><br><span class="line">				System.out.println(<span class="string">&quot;异常message：&quot;</span> + returned.getReplyText());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后配置<code>Publisher Confirm</code>，需要去发送消息的代码处修改：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改之前的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.direct&quot;</span>, <span class="string">&quot;发送的消息内容&quot;</span>, <span class="string">&quot;hello direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改之后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 设置Publisher Confirm回调函数</span></span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (result.isAck()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;消息投递成功&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;消息投递失败&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里springamqp 内部处理时出现的异常，不是mq投递消息失败的异常</span></span><br><span class="line"><span class="comment">		 * 一般是不会出现的</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;spring amqp 处理确认结果异常：&quot;</span> + ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.direct&quot;</span>, <span class="string">&quot;发送的消息内容&quot;</span>, <span class="string">&quot;hello direct&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="（2）确保MQ的可靠性"><a href="#（2）确保MQ的可靠性" class="headerlink" title="（2）确保MQ的可靠性"></a>（2）确保MQ的可靠性</h4><p>在默认情况下，RabbitMQ会将收到的消息保存在内存中，以降低消息收发的延迟，这样会导致两个问题：  </p>
<ul>
<li>一旦MQ宕机，内存中的消息会丢失；  </li>
<li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞。</li>
</ul>
<p>因此可以使用<code>数据持久化</code>和<code>Lazy Queue</code>来确保MQ的可靠性。<br>推荐使用<code>Lazy Queue</code>。  </p>
<p>1、数据持久化<br>RabbitMQ实现数据持久化包括3个方面（每个都要做，下面三个都设置之后，哪怕MQ服务重启都不会丢失消息）：  </p>
<ul>
<li>交换机持久化；<br>在RabbitMQ后台管理系统中，创建交换机时，在<code>Durability</code>选项处选择<code>Durable</code>，代表交换机持久化；而<code>Transient</code>代表临时数据。  </li>
<li>队列持久化，同交换机持久化一样的操作；  </li>
<li>消息持久化。<br>在RabbitMQ后台管理系统中，发送消息时，有个<code>Delivery mode</code>选项，<code>Non-persistent</code>代表临时消息；<code>Persistent</code>代表持久化消息。</li>
</ul>
<p>使用代码测试：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个测试，是用来测试消息设置成持久化之前和之后的性能对比。</span></span><br><span class="line"><span class="comment"> * 注意：测试之前，需要先创建好持久交换机、队列，</span></span><br><span class="line"><span class="comment"> * 并且将配置文件中的关于确保消息发送成功的相关配置关闭</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、将下面message先设置成临时消息，测试一次；</span></span><br><span class="line"><span class="comment"> * 2、再将message设置成持久化消息，测试一次；</span></span><br><span class="line"><span class="comment"> * 3、可以查看RabbitMQ后台管理系统的消息积压情况，可知将message设置成持久化之后，性能会更好。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里因为涉及到消息持久化，所以我们需要自定义构建消息</span></span><br><span class="line"><span class="comment">	 * 使用MessageBuilder消息工厂类自定义消息</span></span><br><span class="line"><span class="comment">	 * withBody()方法：设置消息体，因为它需要字节码，所以这里需要将字符串转换为字节码</span></span><br><span class="line"><span class="comment">	 * setDeliveryMode()方法：设置消息的投递模式，默认是Non-persistent，也就是临时消息</span></span><br><span class="line"><span class="comment">	 * PERSISTENT代表持久化消息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">			.setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">			.build();</span><br><span class="line">	<span class="comment">// 发送1000000条消息</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000000</span>;i ++) &#123;</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;交换机名字&quot;</span>, message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Lazy Queue（直接将消息存入磁盘，不存内存）<br>之前的版本是先将消息存到内存中，然后再根据消息设置，如果设置了消息为持久化，才将消息存入磁盘。而从RabbitMQ的3.6.0版本开始，就增加了Lazy Queue的概念，也就是惰性队列，它的特征是：  </p>
<ul>
<li>接收到消息后直接存入磁盘，不再存储到内存；  </li>
<li>消费者要消费消息时，才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）。</li>
</ul>
<p>也就是说不管消息是临时消息还是持久化消息，直接存入磁盘，不存内存，等消费者要使用消息时，再从磁盘存入内存。<br>注意：在3.12版本后，所有队列都是Lazy Queue模式，无法更改。<br>如果使用3.12之前的版本，需要使用Lazy Queue的话，在RabbitMQ后台管理系统中创建队列的时候，需要在<code>Arguments</code>选项处添加<code>x-queue-mode=lazy</code>参数，这里不需要在输入框输入，可以直接点击下面的<code>Lazy mode</code>即可添加。<br>使用代码的方式添加：<br>要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为lazy即可。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;队列名字&quot;</span>)</span><br><span class="line">	                   .lazy() <span class="comment">// 开启lazy模式</span></span><br><span class="line">					   .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解方式：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">  name = &quot;队列名字&quot;,</span></span><br><span class="line"><span class="meta">  durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">  arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;LazyQueue接收到消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐使用时，都使用这个方式！！！！<br>总结：<br>（1）首先通过配置可以让交换机、队列、以及发送的消息都持久化。这样队列中的消息会持久化到磁盘，MQ重启，消息依然存在；<br>（2）RabbitMQ在3.6版本引入了LazyQueue，并且在3.12版本后会将其设置成队列的默认模式，这个模式会将所有消息都持久化；<br>（3）开启持久化和生产者确认时，RabbitMQ只有在消息持久化完成后才会给生产者返回ACK回执。  </p>
<h4 id="（3）确保消息接收成功"><a href="#（3）确保消息接收成功" class="headerlink" title="（3）确保消息接收成功"></a>（3）确保消息接收成功</h4><p>1、消费者确认机制（针对消息接收服务）<br>消费者确认机制是为了确认消费者是否成功处理消息，一共有三种场景：  </p>
<ul>
<li>返回<code>ACK</code>：表示消费者成功处理消息之后，返回ACK给MQ服务，告知MQ服务自己成功处理消息，让MQ服务将该消息从队列中删除；  </li>
<li>返回<code>NACK</code>：表示消费者处理消息时出现异常，返回NACK给MQ服务，告知MQ服务不要删除消息，将消息重新投递给自己处理，直到成功；  </li>
<li>返回<code>REJECT</code>：表示消费者处理消息时出现异常，并告知MQ服务，拒绝该消息处理，让MQ服务将该消息从队列中删除。</li>
</ul>
<p>注意：上面的三种场景都是消费者处理完之后才能返回，不是刚接收到消息就返回。<br>因为SpringAMQP已经实现了消息确认功能，所以只需要在配置文件中配置处理方式，有三种方式：  </p>
<ul>
<li>none：不处理，即消息投递给消费者后，不管消息是否处理成功，MQ服务都会将消息从队列中删除（默认方式）；  </li>
<li>manual：手动模式，需要自己在业务代码中调用api，发送ACK或REJECT，这种方式可能存在业务入侵；  </li>
<li>auto：自动模式，SpringAMQP利用AOP实现了功能，自动返回不同的结果。</li>
</ul>
<p>在消息接收服务配置：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="attr">listener:</span> </span><br><span class="line">	  <span class="attr">simple:</span></span><br><span class="line">	    <span class="attr">acknowledge-mode:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>
<p>针对上面消费者确认机制中的第二种场景，返回NACK，如果消费者（即消息接收服务）一直处理失败，MQ服务就会一直投递，这是不可取的，会让MQ服务有很大压力，所以我们还需要设置<code>失败重试机制</code>。<br>在消息接收服务配置：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">rabbitmq:</span> </span><br><span class="line">    <span class="attr">listener:</span> </span><br><span class="line">	  <span class="attr">simple:</span> </span><br><span class="line">	    <span class="attr">retry:</span> </span><br><span class="line">		  <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试，默认时关闭的</span></span><br><span class="line">		  <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初始的失败等待时长为1s</span></span><br><span class="line">		  <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 下次失败的等待时长倍数，下次等待时长 = multiplier * initial-interval</span></span><br><span class="line">		  <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">		  <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># 是否无状态，true无状态，false有状态，如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>
<p>注意：<br>（1）如果<code>stateless</code>设置为false，表示有事务，那么<code>max-attempts</code>属性将失效，因为涉及到事务，所以不能重试；<br>（2）如果<code>stateless</code>设置为true，表示无事务，那么<code>max-attempts</code>属性生效，可以重试。<br>这里介绍下重试策略：<br>在开启重试模式后，重试次数耗尽，如果消息依然存在，则需要有<code>MessageRecoverer</code>接口来处理，它有三种不同实现：  </p>
<ul>
<li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject拒绝消息，丢弃消息，不再重试（默认方式）；  </li>
<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回NACK，消息重新入队等待消费；  </li>
<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。<br>将重试策略修改为<code>RepublishMessageRecoverer</code>，在消息接收服务创建配置类：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建定义交换机</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;交换机名字&quot;</span>); <span class="comment">// error.direct</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建定义队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;队列名字&quot;</span>); <span class="comment">// error.queue</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 绑定交换机和队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">errorQueueBinding</span><span class="params">(Queue errorQueue, DirectExchange errorExchange)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(errorQueue)</span><br><span class="line">		                     .to(errorExchange)</span><br><span class="line">		                     .with(<span class="string">&quot;路由键名字&quot;</span>); <span class="comment">// error</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重试策略</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MessageRecoverer <span class="title function_">messageRecoverer</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// return new RepublishMessageRecoverer(rabbitTemplate, &quot;error.direct&quot;, &quot;error&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;交换机名字&quot;</span>, <span class="string">&quot;路由键名字&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
现在还有这么一个问题，就是消费者重复处理问题，比如消费者处理完消息后，要返回状态给MQ服务，此时因为网络原因，MQ服务没有收到消费者的恢复，MQ服务就会将消息重新投递给消费者，导致消费者重复处理消息。<br>解决方法一：<code>唯一消息id</code><br>给每个消息都设置一个唯一id，利用id区分是否是重复消息：<br>（1）每一条消息都生成一个唯一的id，与消息一起投递给消费者；<br>（2）消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库；<br>（3）如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息，放弃处理。<br>在消息发送服务（消息提供者）修改消息转换器，让消息转换器帮我们生成消息id：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Jackson2JsonMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">	converter.setCreateMessageIds(<span class="literal">true</span>); <span class="comment">// 开启消息id生成</span></span><br><span class="line">	<span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在消息接收服务（消费者）接收消息id：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之前是消息发送服务发送的是什么类型的消息，消息接收服务接收消息就是什么类型的消息</span></span><br><span class="line"><span class="comment"> * 现在修改为使用Message类来接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取消息id</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">	<span class="comment">// 获取消息内容</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">	System.out.println(<span class="string">&quot;消息id：&quot;</span> + messageId);</span><br><span class="line">	System.out.println(<span class="string">&quot;消息内容：&quot;</span> + content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决方法二：<code>基于业务判断</code><br>在MQ服务第一次投递给消费者处理之前，先查询数据库，判断消息是否已经处理过，如果处理过则直接返回ACK，不再处理。具体例子查看<a href="/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-54">SpringCloud学习笔记第五点其他问题的第4点</a>。  </p>
<h4 id="（4）延迟消息"><a href="#（4）延迟消息" class="headerlink" title="（4）延迟消息"></a>（4）延迟消息</h4><p>1、使用场景<br>保证服务A和服务B一致性，通常是基于消息队列，由服务A通知服务B，去保证一致性。但是因为某个原因，导致这种方案就是不能成功（不能保证一致性），所以此时就必须有一个兜底方案，就是消息延迟。<br>延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。<br>就比如通常情况下，都是服务A通知服务B，延迟消息就是有一个<code>专门接收延迟消息的消息队列</code>，服务A通知服务B的同时，也发一个延迟消息给这个消息队列（设置一个延迟时间，比如15分钟），然后服务A等待服务B回执15分钟，如果15分钟之后还是没有服务B的回执，那服务A就主动去远程查询（调用）服务B。<br>2、实现方式<br>（1）死信交换机<br>（2）延迟消息插件<br>3、<code>死信交换机</code><br>（1）解释<br>当一个队列中的消息满足下列情况之一时，就会成为死信：  </p>
<ul>
<li>消费者使用<code>reject</code>或<code>nack</code>返回消费失败，并且消息被设置成不想重新投递（消息的requeue参数设置为false）；  </li>
<li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；  </li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li>
</ul>
<p>默认情况下，消息成为死信会被删除。<br>如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的消息成为死信后，就会投递到被指定的这个交换机中，这个交换机就是<code>死信交换机（DLX）</code>。<br>所以<code>死信交换机</code>：就是专门用来接收死信的交换机。<br>现在使用<code>死信交换机</code>来做<code>延迟消息</code>，下图所示：  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="">  
<p>注意：如果使用了key，那么死信交换机、死信队列要和上面交换机、队列的key保持一致。<br>（2）代码实现<br>定义一个死信交换机和死信队列：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">  value = @Queue(name = &quot;dlx.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">  exchange = @Exchange(name = &quot;dlx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlxQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;接收到死信队列的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能使用上面的方法来定义交换机、队列，因为使用上面的方法就会有消费者监听。需要使用传统的方式定义一个普通交换机、普通队列，并设置死信交换机：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建定义交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;normal.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建定义队列，并设置dead-letter-exchange属性，绑定一个死信交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;normal.queue&quot;</span>)</span><br><span class="line">					 .deadLetterExchange(<span class="string">&quot;dlx.direct&quot;</span>)</span><br><span class="line">					 .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定交换机和队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">normalExchangeBinding</span><span class="params">(Queue normalQueue, DirectExchange normalExchange)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 第一个参数：交换机名字</span></span><br><span class="line"><span class="comment">	 * 第二个参数：路由键名字</span></span><br><span class="line"><span class="comment">	 * 第三个参数：消息内容</span></span><br><span class="line"><span class="comment">	 * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;normal.direct&quot;</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello world&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">      <span class="comment">// 设置消息过期时间10s</span></span><br><span class="line">      message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<code>延迟消息插件</code>（DelayExchange插件）<br>因为上面<code>死信交换机</code>实现比较繁琐，需要创建定义多个交换机和队列，容易出错，所以可以使用<code>延迟消息插件</code>。<br>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。<br><a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq#installing-the-plugin">关于插件下载请点击</a>，插件版本要和MQ版本保持一致，比如MQ是3.8，那么插件也要3.8。<br>（1）安装插件（基于Docker安装）<br>如果MQ是基于Docker安装的，才看这个。<br>先查看RabbitMQ的插件目录对应的数据卷：<code>docker volume inspect mq-plugins</code>，<code>mq-plugins</code>是数据卷的名字，如果挂载的数据卷名字不是这个，需要根据自己的数据卷名字修改，可以使用<code>docker volume ls</code>查看所有数据卷列表。<br>可以看到<code>Mountpoint</code>属性，表示插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，上传下载下来的插件到该目录。<br>然后执行命令，安装插件：<code>docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，<code>-it</code>后面的mq是容器的名字，根据自己的容器名修改。<br>（2）使用<br>通过注解方式：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delayed属性设为true，表示是延迟交换机</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">  value = @Queue(name = &quot;队列名字&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">  exchange = @Exchange(name = &quot;交换机名字&quot;, type = ExchangeTypes.DIRECT, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;接收到延迟队列的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码方式：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">			.directExchange(<span class="string">&quot;交换机名字&quot;</span>)</span><br><span class="line">			.delayed() <span class="comment">// 设置delay属性为true</span></span><br><span class="line">			.durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息是需要通过消息头<code>x-delay</code>来设置过期时间：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 第一个参数：交换机名字</span></span><br><span class="line"><span class="comment">	 * 第二个参数：路由键名字</span></span><br><span class="line"><span class="comment">	 * 第三个参数：消息内容</span></span><br><span class="line"><span class="comment">	 * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello world&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">      <span class="comment">// 设置消息过期时间10s</span></span><br><span class="line">      message.getMessageProperties().setDelay(<span class="number">10000</span>);</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、具体使用<code>延迟消息插件</code>示例<br>请查看<a href="/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-55">SpringCloud学习笔记中其他问题章节的第5点</a>。  </p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar/avatar.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar/avatar.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">十七</div><div class="post-copyright__author_desc">积少成多，只要学不死就往死里学v👀</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://zc-zjy.github.io/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://zc-zjy.github.io/2024/12/18/消息队列学习笔记/')">消息队列学习笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/reward/zjyzanshang.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/zjyzanshang.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/reward/zjyzfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/reward/zjyzfb.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://zc-zjy.github.io/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=消息队列学习笔记&amp;url=https://zc-zjy.github.io/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&amp;pic=/img/page_background/cover_background_light.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zc-zjy.github.io" target="_blank">小Z成长录😀丶</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>工作技能<span class="tagsPageCount">39</span></a><a class="post-meta__box__tags" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>后端<span class="tagsPageCount">25</span></a><a class="post-meta__box__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>消息队列<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/page_background/cover_background_light.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/12/ElasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ElasticSearch学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/10/07/Java8-stream-%E8%B0%83%E5%BC%8F%E6%96%B9%E6%B3%95/" title="Java8 stream 调式方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-07</div><div class="title">Java8 stream 调式方法</div></div></a></div><div><a href="/2023/10/07/ObjectMapper%EF%BC%88%E5%90%84%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%92%8CJson%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%EF%BC%89/" title="ObjectMapper（各个类型和Json类型互转）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-07</div><div class="title">ObjectMapper（各个类型和Json类型互转）</div></div></a></div><div><a href="/2023/10/16/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Mybatis学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-16</div><div class="title">Mybatis学习笔记</div></div></a></div><div><a href="/2023/12/01/StringUtils%E4%B8%ADisEmpty%E5%92%8CisBank%E7%9A%84%E5%8C%BA%E5%88%AB/" title="StringUtils中isEmpty和isBank的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-01</div><div class="title">StringUtils中isEmpty和isBank的区别</div></div></a></div><div><a href="/2023/12/01/%E6%B6%88%E7%81%ADif-else-%E7%9A%84%E6%96%B9%E6%B3%95/" title="消灭if...else...的方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-01</div><div class="title">消灭if...else...的方法</div></div></a></div><div><a href="/2024/01/16/Java-%E5%B0%86Object%E5%AF%B9%E8%B1%A1%E8%BD%AC%E4%B8%BA%E5%88%97%E8%A1%A8/" title="Java 将Object对象转为列表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/page_background/cover_background_light.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-16</div><div class="title">Java 将Object对象转为列表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">喜欢分享，也喜欢交朋友，正在努力钻研java、spring全家桶、前端vue等等技术，梦想成为一名技术大牛</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、消息队列基础介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81RabbitMQ"><span class="toc-number">2.</span> <span class="toc-text">二、RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81RabbitMQ%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、RabbitMQ后台管理系统使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Java%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、Java代码中使用RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">（1）知识介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">（2）快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Work-Queues"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">（3）Work Queues</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.0.3.4.</span> <span class="toc-text">（4）Fanout交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.0.3.5.</span> <span class="toc-text">（5）Direct交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.0.3.6.</span> <span class="toc-text">（6）Topic交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.0.3.7.</span> <span class="toc-text">（7）在代码中声明队列、交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">2.0.3.8.</span> <span class="toc-text">（8）消息转换器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-number">2.0.3.9.</span> <span class="toc-text">（9）消息队列在实际项目中的运用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.4.</span> <span class="toc-text">4、使用过程中遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">（1）确保消息发送成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A1%AE%E4%BF%9DMQ%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">（2）确保MQ的可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E6%88%90%E5%8A%9F"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">（3）确保消息接收成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">（4）延迟消息</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/footer/shangban.jpg" alt="上班摸鱼中~" title="上班摸鱼中~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="十七" target="_blank">十七</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["积少成多，只要学不死就往死里学v👀"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '积少成多，只要学不死就往死里学v👀'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/" title="还没备案喔~">还没备案喔~</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Camunda/" style="font-size: 0.88rem;">Camunda<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 0.88rem;">ElasticSearch<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/IntelliJ-IDEA-2020-3-3-x64%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/" style="font-size: 0.88rem;">IntelliJ IDEA 2020.3.3 x64激活方法<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>14</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>1</sup></a><a href="/tags/Maven/" style="font-size: 0.88rem;">Maven<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 0.88rem;">Mybatis<sup>1</sup></a><a href="/tags/MybatisPlus/" style="font-size: 0.88rem;">MybatisPlus<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>1</sup></a><a href="/tags/Postgresql/" style="font-size: 0.88rem;">Postgresql<sup>1</sup></a><a href="/tags/Postman/" style="font-size: 0.88rem;">Postman<sup>1</sup></a><a href="/tags/SVN/" style="font-size: 0.88rem;">SVN<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>7</sup></a><a href="/tags/Vue/" style="font-size: 0.88rem;">Vue<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>1</sup></a><a href="/tags/navicat/" style="font-size: 0.88rem;">navicat<sup>1</sup></a><a href="/tags/%E4%B9%A6%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">书本知识<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>3</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>25</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/" style="font-size: 0.88rem;">工作技能<sup>39</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/" style="font-size: 0.88rem;">工作流<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>3</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">服务器<sup>3</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">测试工具<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">消息队列<sup>1</sup></a><a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" style="font-size: 0.88rem;">版本控制<sup>2</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/17/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 十七 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("09/17/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "/img/footer/xiaban.jpg";
        img.title = "下班啦啦啦啦，嘿嘿~";
        img.alt = "下班啦啦啦啦，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4240673_wweo9mtor0h.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU,黄洁,十七,小Z,早上好鸭👋, 祝你一天好心情！,上午好👋, 状态很好，鼓励一下～,11点多啦, 在坚持一下就吃饭啦～,午安👋, 宝贝,🌈充实的一天辛苦啦！,奖励一顿丰盛的大餐吧🍔,晚上好👋,晚上好👋, 在属于自己的时间好好放松😌~,晚安😴" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>