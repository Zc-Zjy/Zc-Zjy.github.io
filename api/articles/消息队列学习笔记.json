{"title":"消息队列学习笔记","slug":"消息队列学习笔记","date":"2024-12-18T01:51:12.000Z","updated":"2025-01-07T04:21:39.121Z","comments":true,"path":"api/articles/消息队列学习笔记.json","realPath":null,"excerpt":null,"covers":["/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png","/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png"],"cover":null,"content":"<br/>\n\n\n<hr>\n<br/>\n\n\n<h1 id=\"一、消息队列基础介绍\"><a href=\"#一、消息队列基础介绍\" class=\"headerlink\" title=\"一、消息队列基础介绍\"></a>一、消息队列基础介绍</h1><p>1、背景  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png\" class=\"\">  \n<p>有这么个场景，用户发送请求到<code>支付服务</code>，<code>支付服务</code>远程调用<code>用户服务</code>执行扣减余额业务，等扣减成功之后，<code>支付服务</code>再去更新支付状态，然后分别调用<code>交易服务</code>（更新订单状态）、<code>通知服务</code>（短信通知用户）和<code>积分服务</code>（增加用户积分），这里<code>用户服务</code>的扣减余额和<code>支付服务</code>的更新支付状态是同步处理，也就是说<code>支付服务</code>必须得等待<code>用户服务</code>完成扣减余额操作，返回结果之后才能去更新支付状态，但是其他服务和<code>支付服务</code>就属于异步处理（为什么要异步？因为如果同步的话，每个服务都得等待前一个服务处理完才能处理，这样耗时会很长，性能会很差），其他服务不用等待<code>支付服务</code>的处理结果。<br>上面的场景就可以使用消息队列，而且使用消息队列，后续如果还有新的需求，需求新增加服务，那我们可以不用去更改原来的代码，直接去获取消息队列中的消息即可。  </p>\n<p>2、异步调用<br>异步调用通常是基于消息通知的方式，包含三个角色：<br>（1）消息发送者：投递消息的人，就是原来的调用者；<br>（2）消息接收者：接收和处理消息的人，就是原来的服务提供者；<br>（3）消息代理：管理、暂存、转发消息，可以把它理解成微信服务器。  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png\" class=\"\">  \n<p>就如上面的场景，在<code>支付服务</code>和<code>交易服务</code>、<code>通知服务</code>、<code>积分服务</code>之间加一层<code>消息代理</code>，<code>支付服务</code>只管将消息发送给<code>消息代理</code>，然后其他服务来监听<code>消息代理</code>。  </p>\n<p>3、技术框架  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png\" class=\"\">  \n<p><code>ActiveMQ</code>已被淘汰。  </p>\n<br/>\n\n\n<hr>\n<br/>\n\n\n<h1 id=\"二、RabbitMQ\"><a href=\"#二、RabbitMQ\" class=\"headerlink\" title=\"二、RabbitMQ\"></a>二、RabbitMQ</h1><p><a href=\"https://www.rabbitmq.com/\">官网地址</a>  </p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>1、基于Docker安装<br>提示：如果docker下不下来，请点击<a href=\"https://pan.baidu.com/s/1sOkAciC9WvifdOWTc7fBQw?pwd=frxr\">链接</a>下载本地镜像，提取码：<code>frxr</code>，然后将本地镜像<code>mq.tar</code>加载到docker中，通过<code>docker load -i mq.tar</code>命令加载，加载之后想要删除tar包，执行命令<code>rm -rf mq.tar</code>。  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run \\</span><br><span class=\"line\">  -e RABBITMQ_DEFAULT_USER=admin \\</span><br><span class=\"line\">  -e RABBITMQ_DEFAULT_PASS=admin \\</span><br><span class=\"line\">  -v mq-plugins:/plugins \\</span><br><span class=\"line\">  --name mq \\</span><br><span class=\"line\">  -p 15672:15672 \\</span><br><span class=\"line\">  -p 5672:5672 \\</span><br><span class=\"line\">  --network net\\</span><br><span class=\"line\">  -d \\</span><br><span class=\"line\">  rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>\n<p><code>-e RABBITMQ_DEFAULT_USER=admin</code>：RabbitMQ后台管理系统用户名；<br><code>-e RABBITMQ_DEFAULT_PASS=admin</code>：RabbitMQ后台管理系统密码；<br><code>-v mq-plugins:/plugins</code>：挂载数据卷；<br><code>--name mq</code>：容器名；<br><code>-p 15672:15672</code>：RabbitMQ后台管理系统端口；<br><code>-p 5672:5672</code>：RabbitMQ服务端口；<br><code>--network net</code>：指定网络；<br><code>-d</code>：后台运行；<br><code>rabbitmq:3.8-management</code>：镜像名。<br>其他安装方式查看官网。  </p>\n<h3 id=\"2、RabbitMQ后台管理系统使用\"><a href=\"#2、RabbitMQ后台管理系统使用\" class=\"headerlink\" title=\"2、RabbitMQ后台管理系统使用\"></a>2、RabbitMQ后台管理系统使用</h3><p>1、访问地址<br><code>http://ip:15672</code>，输入配置的用户名和密码访问。  </p>\n<p>2、页面介绍<br><code>Connections</code>Tab页：显示消息发送者和消息接收者，只要连接了RabbitMQ的服务都会在这里显示。<br><code>Channels</code>Tab页：显示消息通道。<br><code>Exchanges</code>Tab页：显示交换机。<br><code>Queues</code>Tab页：显示队列。<br><code>Admin</code>Tab页：管理用户。  </p>\n<p>3、RabbitMQ的整体架构和核心概念  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png\" class=\"\">  \n<p>（1）交换机（exchange）只能路由消息，无法存储消息。<br>（2）交换机（exchange）只会路由消息给与自己绑定的队列，因此队列必须与交换机绑定。  </p>\n<p>4、快速入门需求一<br>（1）需求  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class=\"line\"><span class=\"number\">1</span>、新建队列 hello<span class=\"selector-class\">.queue1</span> 和 hello.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、向默认的 amp<span class=\"selector-class\">.fanout</span> 交换机发送一条消息；</span><br><span class=\"line\"><span class=\"number\">3</span>、查看消息是否到达 hello<span class=\"selector-class\">.queue1</span> 和 hello.queue2。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png\" class=\"\">  \n<p>如上图所示，分别添加hello.queue1和hello.queue2两个队列。<br>然后选中<code>Exchanges</code>Tab页，点击<code>amp.fanout</code>交换机进入交换机详情页，将两个队列与交换机建立关联，如下图所示。  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png\" class=\"\">  \n<p>然后在该页面找到<code>Publish message</code>项，在<code>Payload</code>输入hello，mq！，点击发送之后，我们在<code>Queues</code>Tab页查看，两个队列都收到消息了。  </p>\n<p>5、快速入门需求二<br>（1）需求（数据隔离）  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class=\"line\"><span class=\"number\">1</span>、新建一个用户；</span><br><span class=\"line\"><span class=\"number\">2</span>、为新建的用户创建一个 <span class=\"keyword\">virtual</span> host；</span><br><span class=\"line\"><span class=\"number\">3</span>、测试不同 <span class=\"keyword\">virtual</span> host 之间的数据隔离现象。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤<br>点击<code>Admin</code>Tab页，点击右侧的<code>Users</code>选项，点击<code>Add a user</code>，输入用户名和密码，Tags是用户角色的意思，这里选择超级管理员角色Admin。<br>可以看到刚新建的用户是没有可以访问的virtual host的，退出登录，切换成刚创建的新用户。<br>我们点击<code>Admin</code>Tab页，点击右侧<code>Virtual Hosts</code>选项，点击<code>Add a new virtual host</code>，创建一个新的虚拟机。  </p>\n<h3 id=\"3、Java代码中使用RabbitMQ\"><a href=\"#3、Java代码中使用RabbitMQ\" class=\"headerlink\" title=\"3、Java代码中使用RabbitMQ\"></a>3、Java代码中使用RabbitMQ</h3><h4 id=\"（1）知识介绍\"><a href=\"#（1）知识介绍\" class=\"headerlink\" title=\"（1）知识介绍\"></a>（1）知识介绍</h4><p>演示项目<a href=\"https://gitee.com/zuo-junyuan/microservice-learning-notes\">请点击访问下载</a>，在mq目录<code>mq-demo.zip</code>包。<br><code>AMQP</code>（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准，该协议与语言和平台无关，更符合微服务中独立性的要求。<br><code>Spring AMQP</code>是基于<code>AMQP</code>协议定义的一套API规范，提供了模板来发送和接收消息，它包含两部分，其中<code>spring-amqp</code>是基础抽象，<code>spring-rabbit</code>是底层的默认实现。  </p>\n<h4 id=\"（2）快速入门\"><a href=\"#（2）快速入门\" class=\"headerlink\" title=\"（2）快速入门\"></a>（2）快速入门</h4><p>（1）需求<br>打开上面演示项目，演示项目中包括了两个服务<code>consumer</code>（消息接收者）和<code>publisher</code>（消息发送者）。  </p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、利用RabbitMQ的后台管理系统创建队列 simple.queue；</span><br><span class=\"line\"><span class=\"number\">2</span>、在publisher服务中，利用SpringAMQP直接向simple.queue发送消息；</span><br><span class=\"line\"><span class=\"number\">3</span>、在consumer服务中，利用SpringAMQP编写消费者，监听simple.queue队列。</span><br><span class=\"line\">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤<br>创建队列这里不再做阐述。<br>在父工程中引入<code>spring-amqp</code>依赖，这样publisher和consumer两个服务都可以使用：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在每个服务中配置MQ的服务端信息，这样每个服务才能连接到RabbitMQ：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"comment\"># RabbitMQ的部署ip地址</span></span><br><span class=\"line\">\t<span class=\"attr\">port:</span> <span class=\"number\">5672</span> <span class=\"comment\"># RabbitMQ的服务端口</span></span><br><span class=\"line\">\t<span class=\"attr\">virtual-host:</span> <span class=\"string\">/mq</span> <span class=\"comment\"># 要使用的虚拟机</span></span><br><span class=\"line\">\t<span class=\"attr\">username:</span> <span class=\"string\">admin</span> <span class=\"comment\"># 连接到RabbitMQ的用户名</span></span><br><span class=\"line\">\t<span class=\"attr\">password:</span> <span class=\"string\">admin</span> <span class=\"comment\"># 连接到RabbitMQ的密码</span></span><br></pre></td></tr></table></figure>\n<p>在<code>test/java</code>目录下创建<code>com.itheima.publisher</code>单元测试包（单元测试路径要与main包下的路径保持一致），创建<code>SpringAmqpTest</code>测试类，编写测试代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringAmqpTest</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 需要使用到RabbitTemplate类，这个类amqp包中已经提供了，可以直接注入使用</span></span><br><span class=\"line\"><span class=\"comment\">\t * RabbitTemplate是SpringAMQP提供的用于操作RabbitMQ的工具类</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSimpleQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1、发送消息</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 第一个参数：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 第二个参数：发送消息的内容</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;simple.queue&quot;</span>,<span class=\"string\">&quot;hello, spring amqp!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动之后，可以去RabbitMQ管理后台查看对应的队列中是否收到消息。<br>在<code>consumer</code>服务中编写监听消息的消息接收者，在main&#x2F;java目录下创建mq包，在mq包下新建SpringRabbitListener监听类：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringRabbitListener</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 监听simple.queue队列的消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> msg 消息内容，发送的时候是什么类型，接收的时候就是什么类型</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenSimpleQueue</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;spring amqp 监听到了simple.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动<code>consumer</code>服务，可以看到控制台输出了消息。现在只要<code>publisher</code>服务那边发送了消息，<code>consumer</code>服务这边就会监听到消息，并且输出收到的消息。  </p>\n<h4 id=\"（3）Work-Queues\"><a href=\"#（3）Work-Queues\" class=\"headerlink\" title=\"（3）Work Queues\"></a>（3）Work Queues</h4><p><code>Work Queues</code>：任务模型，简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。注意：队列中的消息只能由这些消费者中的一个接收，比如：队列中有一条消息，这个队列绑定了三个消费者，队列中的这条消息假如被消费者2接收到了，那么消费者1和消费者3是接收不到的。<br>1、需求  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在RabbitMQ后台管理系统中创建一个队列，名为 work.queue；</span><br><span class=\"line\"><span class=\"number\">2</span>、在 publisher 服务中定义测试方法，发送<span class=\"number\">50</span>条消息到 work.queue；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中定义两个消息监听者，都监听 work.queue 队列。</span><br><span class=\"line\">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>基于<code>快速入门</code>中的项目继续做。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenWorkQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenWorkQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWorkQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列名</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">queueName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;work.queue&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送50条消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;i &lt;= <span class=\"number\">50</span>;i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 消息内容</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello, spring amqp! &quot;</span> + i;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t\trabbitTemplate.convertAndSend(queueName, msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启两个服务，可以看到<code>consumer</code>服务的控制台输出，两个消费者分别接收到了25条消息。<br>如果这两个消费者是在两个不同的服务中，消费者1的性能要比消费者2的性能好，这种情况下依然是每个消费者都处理25条。<br>那么我们想实现“能者多劳”的效果，也就是说让消费者1处理更多的消息，可以在配置文件中配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">prefetch:</span> <span class=\"number\">1</span> <span class=\"comment\"># 每次只能获取一条消息，处理完成才能获取下一条消息</span></span><br></pre></td></tr></table></figure>\n<p>3、总结：<code>Work</code>模型的使用  </p>\n<ol>\n<li>多个消费者绑定到一个队列，可以加快消息处理速度；  </li>\n<li>同一条消息只会被一个消费者处理；  </li>\n<li>通过设置<code>prefetch</code>来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳。</li>\n</ol>\n<h4 id=\"（4）Fanout交换机\"><a href=\"#（4）Fanout交换机\" class=\"headerlink\" title=\"（4）Fanout交换机\"></a>（4）Fanout交换机</h4><p>上面的案例都没有涉及到<code>交换机</code>，从上面的案例可以看出，消息可以直接发送到队列，队列还具有存储消息的功能，而交换机并没有存储消息的功能，只有路由消息的功能，那为什么还要有交换机呢？<br>我们可以从<code>Work Queues</code>案例看出，队列中的消息只要被消费者接收之后，就没有该条消息了。那么如果想实现这么一个场景：这条消息想要被所有消费者都接收到（广播的模式），该怎么去实现？这就得用到<code>Fanout</code>类型的交换机了。<br><code>交换机</code>的作用：主要是接收发送者发送的消息，并将消息路由到与其绑定的队列，而<code>Fanout交换机</code>就是可以实现一条消息，所有消费者都能接收到，即<code>广播模式</code>。<br>1、需求  </p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在<span class=\"type\">RabbitMQ</span>后台管理系统中，创建两个队列 fanout.queue1 和 fanout.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、在<span class=\"type\">RabbitMQ</span>后台管理系统中，创建交换机 fanout.exchange，类型<span class=\"keyword\">type</span>为 fanout，并将两个队列与其绑定；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2；</span><br><span class=\"line\"><span class=\"number\">4</span>、在 publisher 服务中，编写测试方法，向 fanout.exchange发送消息。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenFanoutQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了fanout.queue1的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenFanoutQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了fanout.queue2的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFanoutExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交换机名称</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">exchangeName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;fanout.exchange&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：这里为null和&quot;&quot;都行</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;hello,exange fanout!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）Direct交换机\"><a href=\"#（5）Direct交换机\" class=\"headerlink\" title=\"（5）Direct交换机\"></a>（5）Direct交换机</h4><p>有这么个场景：想要实现有些消息是多个消费者接收到，有些消息只有个别消费者收到，这种情况下，就需要用到<code>Direct交换机</code>了。<br><code>Direct交换机</code>：会将接收到的消息根据规则路由到指定的队列，即<code>定向模式</code>。<br>（1）每一个队列在与交换机绑定时，都设置一个key（一般将这个key叫做<code>BindingKey</code>）；<br>（2）发送者发送消息时，指定消息的key（一般将这个key叫做<code>RoutingKey</code>）；<br>（3）交换机将消息路由到<code>BindingKey</code>与<code>RoutingKey</code>一致的队列。<br>1、需求  </p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在RabbitMQ后台管理系统中，创建两个队列 <span class=\"built_in\">direct</span>.queue1 和 <span class=\"built_in\">direct</span>.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、在RabbitMQ后台管理系统中，创建交换机 <span class=\"built_in\">direct</span>.exchange，类型type为 <span class=\"built_in\">direct</span>，并将两个队列与其绑定，绑定的时候在RoutingKey输入框处<span class=\"built_in\">direct</span>.queue1指定red、blue两个<span class=\"built_in\">key</span>，也就是BindingKey（输入的时候只能一个一个的输入去绑定），<span class=\"built_in\">direct</span>.queue2指定red、yellow两个<span class=\"built_in\">key</span>；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 <span class=\"built_in\">direct</span>.queue1 和 <span class=\"built_in\">direct</span>.queue2；</span><br><span class=\"line\"><span class=\"number\">4</span>、在 publisher 服务中，编写测试方法，向 <span class=\"built_in\">direct</span>.exchange发送消息，并指定RoutingKey。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了direct.queue1的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了direct.queue2的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDirectExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交换机名称</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">exchangeName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct.exchange&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：RoutingKey</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;hello,exange direct!&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">\t * 1、如果第二个参数RoutingKey为red，那么direct.queue1和direct.queue2都能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 2、如果第二个参数RoutingKey为blue，那么只有direct.queue1能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 3、如果第二个参数RoutingKey为yellow，那么只有direct.queue2能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 4、如果第二个参数RoutingKey为green，那么direct.queue1和direct.queue2都不能接收到消息。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（6）Topic交换机\"><a href=\"#（6）Topic交换机\" class=\"headerlink\" title=\"（6）Topic交换机\"></a>（6）Topic交换机</h4><p><code>Topic交换机</code>：也是基于RoutingKey做消息路由的，但是它的RoutingKey通常是多个单词的组合，并且以<code>.</code>分隔，即<code>主题模式</code>。<br>队列与交换机指定BindingKey时可以使用通配符：<code>#</code>（0个或多个单词）、<code>*</code>（一个单词）。<br>比如：<br>六个队列与一个交换机绑定时，设置的<code>BindingKey</code>为：<br>队列1为<code>china.news</code>：指中国的新闻消息；<br>队列2为<code>china.weather</code>：指中国的天气消息；<br>队列3为<code>japan.news</code>：指日本的新闻消息；<br>队列4为<code>japan.weather</code>：指日本的天气消息；<br>队列5为<code>china.#</code>：指中国的所有消息；<br>队列6为<code>#.news</code>：指所有的新闻消息。<br>然后发送者发送消息指定的<code>RoutingKey</code>为：<br><code>china.#</code>：所有<code>BindingKey</code>中有<code>china</code>的消费者都收到消息，队列1、队列2、队列5收到消息；<br><code>japan.*</code>：只有<code>BindingKey</code>中有<code>japan</code>后跟一个单词的消费者能接收到消息，队列3、队列4收到消息（<code>japan</code>和<code>japan.xxx.xxx</code>是接收不到消息的）；<br><code>#.weather</code>：只有<code>BindingKey</code>中有<code>weather</code>的消费者能接收到消息，队列2、队列4收到消息；<br><code>china.news</code>：只有<code>BindingKey</code>中有<code>china.news</code>的消费者能接收到消息，队列1、队列5、队列6收到消息；<br><code>china.weather</code>：队列2、队列5收到消息。<br>注意：在创建交换机的时候，类型type为<code>topic</code>。  </p>\n<h4 id=\"（7）在代码中声明队列、交换机\"><a href=\"#（7）在代码中声明队列、交换机\" class=\"headerlink\" title=\"（7）在代码中声明队列、交换机\"></a>（7）在代码中声明队列、交换机</h4><p>1、说明<br>之前所有案例的交换机、队列都是在RabbitMQ的后台管理系统中创建的，实际开发中是不允许这么做，都是在代码中创建的。<br><code>SpringAMQP</code>提供了几个类，用来声明队列、交换机及其绑定关系：<br>（1）<code>Queue</code>：用于声明队列，可以用工厂类<code>QueueBuilder</code>构建；<br>（2）<code>Exchange</code>：用于声明交换机，可以用工厂类<code>ExchangeBuilder</code>构建；<br>（3）<code>Binding</code>：用于声明队列和交换机的绑定关系，可以用工厂类<code>BindingBuilder</code>构建。  </p>\n<p>2、使用配置类声明<br>声明一个<code>Fanout</code>类型的交换机，并且创建队列与其绑定：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FanoutConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明 FanoutExchange 交换机</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> FanoutExchange <span class=\"title function_\">fanoutExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 参数：交换机的名称</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanout.exchange&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明第一个队列</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">fanoutQueueOne</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 参数：队列的名称</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;fanout.queue1&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定队列1和交换机</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">bindingQueueOne</span><span class=\"params\">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 绑定哪个队列到哪个交换机</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果有 BindingKey 在to方法后面调用with方法指定，如果得指定多个 BindingKey 就得再新建一个方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...略，同理，以相同的方式声明第二个队列并完成绑定</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 同一个队列指定多个 BindingKey：</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@Bean</span></span></span><br><span class=\"line\"><span class=\"comment\">\t * public Binding bindingQueueOneRed(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t *   // 指定 第一个 BindingKey 为 Red</span></span><br><span class=\"line\"><span class=\"comment\">\t *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;red&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Bean</span></span></span><br><span class=\"line\"><span class=\"comment\">\t * public Binding bindingQueueOneBlue(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t *   // 指定 第二个 BindingKey 为 Blue</span></span><br><span class=\"line\"><span class=\"comment\">\t *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;blue&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用工厂类来创建队列、交换机及其绑定关系：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FanoutConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明 FanoutExchange 交换机</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> FanoutExchange <span class=\"title function_\">fanoutExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ExchangeBuilder.fanoutExchange(<span class=\"string\">&quot;fanout.exchange&quot;</span>).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明第一个队列</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">fanoutQueueOne</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;fanout.queue1&quot;</span>).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定队列1和交换机</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">bindingQueueOne</span><span class=\"params\">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 绑定哪个队列到哪个交换机</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 指定多个 BindingKey 同上面的方式一样</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：上面的配置类都是写在<code>consumer</code>消费者服务中的！<br>为什么？<br>因为发送者只关心发送消息，将消息发到交换机或队列就行了，而消费者需要去监听队列，需要知道队列和哪个交换机绑定了。<br>上面绑定多个BindingKey方法太繁琐，推荐使用注解方式。  </p>\n<p>3、使用注解方式声明<br><code>SpringAMQP</code>还提供了基于<code>@RabbitListener</code>注解来声明队列和交换机：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">  bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">\texchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">\tkey = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">  )</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueOne</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;消费者1收到消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：上面的注解方式也是写在<code>consumer</code>消费者服务中的，这个注解是使用在需要监听队列的方法上的！  </p>\n<h4 id=\"（8）消息转换器\"><a href=\"#（8）消息转换器\" class=\"headerlink\" title=\"（8）消息转换器\"></a>（8）消息转换器</h4><p>1、说明<br><code>SpringAMQP</code>中默认消息是网络传输，将消息内容（对象）转化成字节，通过字节流进行传输，默认的消息转换器是<code>SimpleMessageConverter</code>实现类，基于JDK的<code>ObjectOutputStream</code>完成序列化。<br>它存在下列问题：<br>（1）JDK的序列化有完全风险；<br>（2）JDK序列化的消息太大；<br>（3）JDK序列化的消息可读性差，是一串乱码。  </p>\n<p>2、修改默认消息转换器<br>推荐使用JSON序列化代替默认的JDK序列化，在publisher和consumer服务中引入jackson依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在publisher和consumer服务中配置MessageConverter消息转换器：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MessageConverter <span class=\"title function_\">messageConverter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonMessageConverter</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（9）消息队列在实际项目中的运用\"><a href=\"#（9）消息队列在实际项目中的运用\" class=\"headerlink\" title=\"（9）消息队列在实际项目中的运用\"></a>（9）消息队列在实际项目中的运用</h4><p>具体查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-53\">SpringCloud学习笔记第五、其他问题消息队列的使用</a>。  </p>\n<h3 id=\"4、使用过程中遇到的问题\"><a href=\"#4、使用过程中遇到的问题\" class=\"headerlink\" title=\"4、使用过程中遇到的问题\"></a>4、使用过程中遇到的问题</h3><h4 id=\"（1）确保消息发送成功\"><a href=\"#（1）确保消息发送成功\" class=\"headerlink\" title=\"（1）确保消息发送成功\"></a>（1）确保消息发送成功</h4><p>1、发送者重连机制（针对消息发送者）<br>场景：假如MQ消息队列服务挂了或者由于网络波动，可能会出现发送者连接MQ失败的情况。<br>在消息发送服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">connection-timeout:</span> <span class=\"string\">1s</span> <span class=\"comment\"># 设置MQ的连接超时时间，例如：等了1s还没连上就认为连接超时</span></span><br><span class=\"line\">\t<span class=\"attr\">template:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">retry:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启超时重试机制，默认是没有开启</span></span><br><span class=\"line\">\t\t<span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span> <span class=\"comment\"># 重连失败后的初始等待时间，例如：连接超时之后不会立刻去重连，会等待1000ms再去重连</span></span><br><span class=\"line\">\t\t<span class=\"attr\">multiplier:</span> <span class=\"number\">1</span> <span class=\"comment\"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier，例如：如果设置为2，第一次等待1000ms（因为初始等待时间设置的是1000ms），第二次等待2000ms，第三次4000ms</span></span><br><span class=\"line\">\t\t<span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span> <span class=\"comment\"># 最大重连次数</span></span><br></pre></td></tr></table></figure>\n<p>注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率，不过SpringAMQP提供的重试机制是阻塞式的重试，也即是说在重试期间，发送消息服务会一直在重试，直到重试成功或者达到重试最大次数，才会继续往下执行业务，会影响业务性能。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，也可以考虑使用异步线程来执行发送消息的代码。  </p>\n<p>2、发送者确认机制（针对消息发送者）<br>SpringAMQP有<code>Publisher Confirm</code>和<code>Publisher Return</code>两种确认机制（是一起使用的）。开启确认机制后，当发送消息服务给MQ发送消息后，MQ会返回确认结果给发送消息服务，返回结果有以下几种情况：<br>（1）消息投递到了MQ，但是路由失败（没有绑定队列或者代码错误）。此时会通过PublisherReturn返回路由异常原因，然后返回ACK（确认结果），告知消息投递成功；<br>（2）临时消息（不需要持久化的消息）投递到了MQ，并且入队成功，返回ACK，告知投递成功；<br>（3）持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功；<br>（4）其他情况都会返回NACK，告知投递失败。<br>一般收到NACK都需要重发消息，收到ACK的记录日志。<br>在发送消息服务的配置文件中配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"comment\"># publisher-confirm-type有三种模式：</span></span><br><span class=\"line\">\t<span class=\"comment\"># 1. none：关闭confirm机制，默认</span></span><br><span class=\"line\">\t<span class=\"comment\"># 2. simple：同步阻塞等待MQ的回执消息</span></span><br><span class=\"line\">\t<span class=\"comment\"># 3. correlated：MQ异步回调方式返回回执消息</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span> <span class=\"comment\"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class=\"line\">\t<span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启publisher return机制，默认为false</span></span><br></pre></td></tr></table></figure>\n<p>配置<code>Publisher Return</code>，创建一个MQ配置类：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MQConfig</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置Publisher Return回调函数</span></span><br><span class=\"line\">\t\trabbitTemplate.setReturnsCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(ReturnedMessage returned)</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;交换机为：&quot;</span> + returned.getExchange());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;routingKey：&quot;</span> + returned.getRoutingKey());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息本身message：&quot;</span> + returned.getMessage());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;异常code：&quot;</span> + returned.getReplyCode());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;异常message：&quot;</span> + returned.getReplyText());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后配置<code>Publisher Confirm</code>，需要去发送消息的代码处修改：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改之前的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSendMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange.direct&quot;</span>, <span class=\"string\">&quot;发送的消息内容&quot;</span>, <span class=\"string\">&quot;hello direct&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改之后的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSendMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置Publisher Confirm回调函数</span></span><br><span class=\"line\">\t<span class=\"type\">CorrelationData</span> <span class=\"variable\">cd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class=\"line\">\tcd.getFuture().addCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(CorrelationData.Confirm result)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (result.isAck()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息投递成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息投递失败&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 这里springamqp 内部处理时出现的异常，不是mq投递消息失败的异常</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 一般是不会出现的</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onFailure</span><span class=\"params\">(Throwable ex)</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;spring amqp 处理确认结果异常：&quot;</span> + ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange.direct&quot;</span>, <span class=\"string\">&quot;发送的消息内容&quot;</span>, <span class=\"string\">&quot;hello direct&quot;</span>, cd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"（2）确保MQ的可靠性\"><a href=\"#（2）确保MQ的可靠性\" class=\"headerlink\" title=\"（2）确保MQ的可靠性\"></a>（2）确保MQ的可靠性</h4><p>在默认情况下，RabbitMQ会将收到的消息保存在内存中，以降低消息收发的延迟，这样会导致两个问题：  </p>\n<ul>\n<li>一旦MQ宕机，内存中的消息会丢失；  </li>\n<li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞。</li>\n</ul>\n<p>因此可以使用<code>数据持久化</code>和<code>Lazy Queue</code>来确保MQ的可靠性。<br>推荐使用<code>Lazy Queue</code>。  </p>\n<p>1、数据持久化<br>RabbitMQ实现数据持久化包括3个方面（每个都要做，下面三个都设置之后，哪怕MQ服务重启都不会丢失消息）：  </p>\n<ul>\n<li>交换机持久化；<br>在RabbitMQ后台管理系统中，创建交换机时，在<code>Durability</code>选项处选择<code>Durable</code>，代表交换机持久化；而<code>Transient</code>代表临时数据。  </li>\n<li>队列持久化，同交换机持久化一样的操作；  </li>\n<li>消息持久化。<br>在RabbitMQ后台管理系统中，发送消息时，有个<code>Delivery mode</code>选项，<code>Non-persistent</code>代表临时消息；<code>Persistent</code>代表持久化消息。</li>\n</ul>\n<p>使用代码测试：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个测试，是用来测试消息设置成持久化之前和之后的性能对比。</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：测试之前，需要先创建好持久交换机、队列，</span></span><br><span class=\"line\"><span class=\"comment\"> * 并且将配置文件中的关于确保消息发送成功的相关配置关闭</span></span><br><span class=\"line\"><span class=\"comment\"> * 步骤：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1、将下面message先设置成临时消息，测试一次；</span></span><br><span class=\"line\"><span class=\"comment\"> * 2、再将message设置成持久化消息，测试一次；</span></span><br><span class=\"line\"><span class=\"comment\"> * 3、可以查看RabbitMQ后台管理系统的消息积压情况，可知将message设置成持久化之后，性能会更好。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testSendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这里因为涉及到消息持久化，所以我们需要自定义构建消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * 使用MessageBuilder消息工厂类自定义消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * withBody()方法：设置消息体，因为它需要字节码，所以这里需要将字符串转换为字节码</span></span><br><span class=\"line\"><span class=\"comment\">\t * setDeliveryMode()方法：设置消息的投递模式，默认是Non-persistent，也就是临时消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * PERSISTENT代表持久化消息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> MessageBuilder.withBody(<span class=\"string\">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class=\"line\">\t\t\t.setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class=\"line\">\t\t\t.build();</span><br><span class=\"line\">\t<span class=\"comment\">// 发送1000000条消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; <span class=\"number\">1000000</span>;i ++) &#123;</span><br><span class=\"line\">\t\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;交换机名字&quot;</span>, message);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、Lazy Queue（直接将消息存入磁盘，不存内存）<br>之前的版本是先将消息存到内存中，然后再根据消息设置，如果设置了消息为持久化，才将消息存入磁盘。而从RabbitMQ的3.6.0版本开始，就增加了Lazy Queue的概念，也就是惰性队列，它的特征是：  </p>\n<ul>\n<li>接收到消息后直接存入磁盘，不再存储到内存；  </li>\n<li>消费者要消费消息时，才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）。</li>\n</ul>\n<p>也就是说不管消息是临时消息还是持久化消息，直接存入磁盘，不存内存，等消费者要使用消息时，再从磁盘存入内存。<br>注意：在3.12版本后，所有队列都是Lazy Queue模式，无法更改。<br>如果使用3.12之前的版本，需要使用Lazy Queue的话，在RabbitMQ后台管理系统中创建队列的时候，需要在<code>Arguments</code>选项处添加<code>x-queue-mode=lazy</code>参数，这里不需要在输入框输入，可以直接点击下面的<code>Lazy mode</code>即可添加。<br>使用代码的方式添加：<br>要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为lazy即可。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">lazyQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;队列名字&quot;</span>)</span><br><span class=\"line\">\t                   .lazy() <span class=\"comment\">// 开启lazy模式</span></span><br><span class=\"line\">\t\t\t\t\t   .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注解方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class=\"line\"><span class=\"meta\">  name = &quot;队列名字&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">  durable = &quot;true&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">  arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenLazyQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;LazyQueue接收到消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>推荐使用时，都使用这个方式！！！！<br>总结：<br>（1）首先通过配置可以让交换机、队列、以及发送的消息都持久化。这样队列中的消息会持久化到磁盘，MQ重启，消息依然存在；<br>（2）RabbitMQ在3.6版本引入了LazyQueue，并且在3.12版本后会将其设置成队列的默认模式，这个模式会将所有消息都持久化；<br>（3）开启持久化和生产者确认时，RabbitMQ只有在消息持久化完成后才会给生产者返回ACK回执。  </p>\n<h4 id=\"（3）确保消息接收成功\"><a href=\"#（3）确保消息接收成功\" class=\"headerlink\" title=\"（3）确保消息接收成功\"></a>（3）确保消息接收成功</h4><p>1、消费者确认机制（针对消息接收服务）<br>消费者确认机制是为了确认消费者是否成功处理消息，一共有三种场景：  </p>\n<ul>\n<li>返回<code>ACK</code>：表示消费者成功处理消息之后，返回ACK给MQ服务，告知MQ服务自己成功处理消息，让MQ服务将该消息从队列中删除；  </li>\n<li>返回<code>NACK</code>：表示消费者处理消息时出现异常，返回NACK给MQ服务，告知MQ服务不要删除消息，将消息重新投递给自己处理，直到成功；  </li>\n<li>返回<code>REJECT</code>：表示消费者处理消息时出现异常，并告知MQ服务，拒绝该消息处理，让MQ服务将该消息从队列中删除。</li>\n</ul>\n<p>注意：上面的三种场景都是消费者处理完之后才能返回，不是刚接收到消息就返回。<br>因为SpringAMQP已经实现了消息确认功能，所以只需要在配置文件中配置处理方式，有三种方式：  </p>\n<ul>\n<li>none：不处理，即消息投递给消费者后，不管消息是否处理成功，MQ服务都会将消息从队列中删除（默认方式）；  </li>\n<li>manual：手动模式，需要自己在业务代码中调用api，发送ACK或REJECT，这种方式可能存在业务入侵；  </li>\n<li>auto：自动模式，SpringAMQP利用AOP实现了功能，自动返回不同的结果。</li>\n</ul>\n<p>在消息接收服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span></span><br><span class=\"line\">\t    <span class=\"attr\">acknowledge-mode:</span> <span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n<p>针对上面消费者确认机制中的第二种场景，返回NACK，如果消费者（即消息接收服务）一直处理失败，MQ服务就会一直投递，这是不可取的，会让MQ服务有很大压力，所以我们还需要设置<code>失败重试机制</code>。<br>在消息接收服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">retry:</span> </span><br><span class=\"line\">\t\t  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启消费者失败重试，默认时关闭的</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span> <span class=\"comment\"># 初始的失败等待时长为1s</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">multiplier:</span> <span class=\"number\">1</span> <span class=\"comment\"># 下次失败的等待时长倍数，下次等待时长 = multiplier * initial-interval</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span> <span class=\"comment\"># 最大重试次数</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">stateless:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 是否无状态，true无状态，false有状态，如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>（1）如果<code>stateless</code>设置为false，表示有事务，那么<code>max-attempts</code>属性将失效，因为涉及到事务，所以不能重试；<br>（2）如果<code>stateless</code>设置为true，表示无事务，那么<code>max-attempts</code>属性生效，可以重试。<br>这里介绍下重试策略：<br>在开启重试模式后，重试次数耗尽，如果消息依然存在，则需要有<code>MessageRecoverer</code>接口来处理，它有三种不同实现：  </p>\n<ul>\n<li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject拒绝消息，丢弃消息，不再重试（默认方式）；  </li>\n<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回NACK，消息重新入队等待消费；  </li>\n<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。<br>将重试策略修改为<code>RepublishMessageRecoverer</code>，在消息接收服务创建配置类：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ErrorMessageConfig</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建定义交换机</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">errorExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;交换机名字&quot;</span>); <span class=\"comment\">// error.direct</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建定义队列</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">errorQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;队列名字&quot;</span>); <span class=\"comment\">// error.queue</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 绑定交换机和队列</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">errorQueueBinding</span><span class=\"params\">(Queue errorQueue, DirectExchange errorExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(errorQueue)</span><br><span class=\"line\">\t\t                     .to(errorExchange)</span><br><span class=\"line\">\t\t                     .with(<span class=\"string\">&quot;路由键名字&quot;</span>); <span class=\"comment\">// error</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 重试策略</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MessageRecoverer <span class=\"title function_\">messageRecoverer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// return new RepublishMessageRecoverer(rabbitTemplate, &quot;error.direct&quot;, &quot;error&quot;);</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RepublishMessageRecoverer</span>(rabbitTemplate, <span class=\"string\">&quot;交换机名字&quot;</span>, <span class=\"string\">&quot;路由键名字&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n现在还有这么一个问题，就是消费者重复处理问题，比如消费者处理完消息后，要返回状态给MQ服务，此时因为网络原因，MQ服务没有收到消费者的恢复，MQ服务就会将消息重新投递给消费者，导致消费者重复处理消息。<br>解决方法一：<code>唯一消息id</code><br>给每个消息都设置一个唯一id，利用id区分是否是重复消息：<br>（1）每一条消息都生成一个唯一的id，与消息一起投递给消费者；<br>（2）消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库；<br>（3）如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息，放弃处理。<br>在消息发送服务（消息提供者）修改消息转换器，让消息转换器帮我们生成消息id：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MessageConverter <span class=\"title function_\">messageConverter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">Jackson2JsonMessageConverter</span> <span class=\"variable\">converter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonMessageConverter</span>();</span><br><span class=\"line\">\tconverter.setCreateMessageIds(<span class=\"literal\">true</span>); <span class=\"comment\">// 开启消息id生成</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> converter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在消息接收服务（消费者）接收消息id：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 之前是消息发送服务发送的是什么类型的消息，消息接收服务接收消息就是什么类型的消息</span></span><br><span class=\"line\"><span class=\"comment\"> * 现在修改为使用Message类来接收消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;queue.name&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveMessage</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取消息id</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">messageId</span> <span class=\"operator\">=</span> message.getMessageProperties().getMessageId();</span><br><span class=\"line\">\t<span class=\"comment\">// 获取消息内容</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody());</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消息id：&quot;</span> + messageId);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消息内容：&quot;</span> + content);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>解决方法二：<code>基于业务判断</code><br>在MQ服务第一次投递给消费者处理之前，先查询数据库，判断消息是否已经处理过，如果处理过则直接返回ACK，不再处理。具体例子查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-54\">SpringCloud学习笔记第五点其他问题的第4点</a>。  </p>\n<h4 id=\"（4）延迟消息\"><a href=\"#（4）延迟消息\" class=\"headerlink\" title=\"（4）延迟消息\"></a>（4）延迟消息</h4><p>1、使用场景<br>保证服务A和服务B一致性，通常是基于消息队列，由服务A通知服务B，去保证一致性。但是因为某个原因，导致这种方案就是不能成功（不能保证一致性），所以此时就必须有一个兜底方案，就是消息延迟。<br>延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。<br>就比如通常情况下，都是服务A通知服务B，延迟消息就是有一个<code>专门接收延迟消息的消息队列</code>，服务A通知服务B的同时，也发一个延迟消息给这个消息队列（设置一个延迟时间，比如15分钟），然后服务A等待服务B回执15分钟，如果15分钟之后还是没有服务B的回执，那服务A就主动去远程查询（调用）服务B。<br>2、实现方式<br>（1）死信交换机<br>（2）延迟消息插件<br>3、<code>死信交换机</code><br>（1）解释<br>当一个队列中的消息满足下列情况之一时，就会成为死信：  </p>\n<ul>\n<li>消费者使用<code>reject</code>或<code>nack</code>返回消费失败，并且消息被设置成不想重新投递（消息的requeue参数设置为false）；  </li>\n<li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；  </li>\n<li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li>\n</ul>\n<p>默认情况下，消息成为死信会被删除。<br>如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的消息成为死信后，就会投递到被指定的这个交换机中，这个交换机就是<code>死信交换机（DLX）</code>。<br>所以<code>死信交换机</code>：就是专门用来接收死信的交换机。<br>现在使用<code>死信交换机</code>来做<code>延迟消息</code>，下图所示：  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png\" class=\"\">  \n<p>注意：如果使用了key，那么死信交换机、死信队列要和上面交换机、队列的key保持一致。<br>（2）代码实现<br>定义一个死信交换机和死信队列：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">  value = @Queue(name = &quot;dlx.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  exchange = @Exchange(name = &quot;dlx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDlxQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;接收到死信队列的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不能使用上面的方法来定义交换机、队列，因为使用上面的方法就会有消费者监听。需要使用传统的方式定义一个普通交换机、普通队列，并设置死信交换机：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建定义交换机</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">normalExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;normal.direct&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建定义队列，并设置dead-letter-exchange属性，绑定一个死信交换机</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">normalQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;normal.queue&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t .deadLetterExchange(<span class=\"string\">&quot;dlx.direct&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 绑定交换机和队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Binding <span class=\"title function_\">normalExchangeBinding</span><span class=\"params\">(Queue normalQueue, DirectExchange normalExchange)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class=\"string\">&quot;hi&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送消息：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：路由键名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  rabbitTemplate.convertAndSend(<span class=\"string\">&quot;normal.direct&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>, <span class=\"string\">&quot;hello world&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">MessagePostProcessor</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Message <span class=\"title function_\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置消息过期时间10s</span></span><br><span class=\"line\">      message.getMessageProperties().setExpiration(<span class=\"string\">&quot;10000&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、<code>延迟消息插件</code>（DelayExchange插件）<br>因为上面<code>死信交换机</code>实现比较繁琐，需要创建定义多个交换机和队列，容易出错，所以可以使用<code>延迟消息插件</code>。<br>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。<br><a href=\"https://blog.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq#installing-the-plugin\">关于插件下载请点击</a>，插件版本要和MQ版本保持一致，比如MQ是3.8，那么插件也要3.8。<br>（1）安装插件（基于Docker安装）<br>如果MQ是基于Docker安装的，才看这个。<br>先查看RabbitMQ的插件目录对应的数据卷：<code>docker volume inspect mq-plugins</code>，<code>mq-plugins</code>是数据卷的名字，如果挂载的数据卷名字不是这个，需要根据自己的数据卷名字修改，可以使用<code>docker volume ls</code>查看所有数据卷列表。<br>可以看到<code>Mountpoint</code>属性，表示插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，上传下载下来的插件到该目录。<br>然后执行命令，安装插件：<code>docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，<code>-it</code>后面的mq是容器的名字，根据自己的容器名修改。<br>（2）使用<br>通过注解方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// delayed属性设为true，表示是延迟交换机</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">  value = @Queue(name = &quot;队列名字&quot;, durable = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  exchange = @Exchange(name = &quot;交换机名字&quot;, type = ExchangeTypes.DIRECT, delayed = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;接收到延迟队列的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过代码方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">delayExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ExchangeBuilder</span><br><span class=\"line\">\t\t\t.directExchange(<span class=\"string\">&quot;交换机名字&quot;</span>)</span><br><span class=\"line\">\t\t\t.delayed() <span class=\"comment\">// 设置delay属性为true</span></span><br><span class=\"line\">\t\t\t.durable(<span class=\"literal\">true</span>) <span class=\"comment\">// 持久化</span></span><br><span class=\"line\">\t\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送消息是需要通过消息头<code>x-delay</code>来设置过期时间：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：路由键名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  rabbitTemplate.convertAndSend(<span class=\"string\">&quot;delay.direct&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>, <span class=\"string\">&quot;hello world&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">MessagePostProcessor</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Message <span class=\"title function_\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置消息过期时间10s</span></span><br><span class=\"line\">      message.getMessageProperties().setDelay(<span class=\"number\">10000</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、具体使用<code>延迟消息插件</code>示例<br>请查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-55\">SpringCloud学习笔记中其他问题章节的第5点</a>。  </p>\n","more":"<br/>\n\n\n<hr>\n<br/>\n\n\n<h1 id=\"一、消息队列基础介绍\"><a href=\"#一、消息队列基础介绍\" class=\"headerlink\" title=\"一、消息队列基础介绍\"></a>一、消息队列基础介绍</h1><p>1、背景  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png\" class=\"\">  \n<p>有这么个场景，用户发送请求到<code>支付服务</code>，<code>支付服务</code>远程调用<code>用户服务</code>执行扣减余额业务，等扣减成功之后，<code>支付服务</code>再去更新支付状态，然后分别调用<code>交易服务</code>（更新订单状态）、<code>通知服务</code>（短信通知用户）和<code>积分服务</code>（增加用户积分），这里<code>用户服务</code>的扣减余额和<code>支付服务</code>的更新支付状态是同步处理，也就是说<code>支付服务</code>必须得等待<code>用户服务</code>完成扣减余额操作，返回结果之后才能去更新支付状态，但是其他服务和<code>支付服务</code>就属于异步处理（为什么要异步？因为如果同步的话，每个服务都得等待前一个服务处理完才能处理，这样耗时会很长，性能会很差），其他服务不用等待<code>支付服务</code>的处理结果。<br>上面的场景就可以使用消息队列，而且使用消息队列，后续如果还有新的需求，需求新增加服务，那我们可以不用去更改原来的代码，直接去获取消息队列中的消息即可。  </p>\n<p>2、异步调用<br>异步调用通常是基于消息通知的方式，包含三个角色：<br>（1）消息发送者：投递消息的人，就是原来的调用者；<br>（2）消息接收者：接收和处理消息的人，就是原来的服务提供者；<br>（3）消息代理：管理、暂存、转发消息，可以把它理解成微信服务器。  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png\" class=\"\">  \n<p>就如上面的场景，在<code>支付服务</code>和<code>交易服务</code>、<code>通知服务</code>、<code>积分服务</code>之间加一层<code>消息代理</code>，<code>支付服务</code>只管将消息发送给<code>消息代理</code>，然后其他服务来监听<code>消息代理</code>。  </p>\n<p>3、技术框架  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png\" class=\"\">  \n<p><code>ActiveMQ</code>已被淘汰。  </p>\n<br/>\n\n\n<hr>\n<br/>\n\n\n<h1 id=\"二、RabbitMQ\"><a href=\"#二、RabbitMQ\" class=\"headerlink\" title=\"二、RabbitMQ\"></a>二、RabbitMQ</h1><p><a href=\"https://www.rabbitmq.com/\">官网地址</a>  </p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>1、基于Docker安装<br>提示：如果docker下不下来，请点击<a href=\"https://pan.baidu.com/s/1sOkAciC9WvifdOWTc7fBQw?pwd=frxr\">链接</a>下载本地镜像，提取码：<code>frxr</code>，然后将本地镜像<code>mq.tar</code>加载到docker中，通过<code>docker load -i mq.tar</code>命令加载，加载之后想要删除tar包，执行命令<code>rm -rf mq.tar</code>。  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run \\</span><br><span class=\"line\">  -e RABBITMQ_DEFAULT_USER=admin \\</span><br><span class=\"line\">  -e RABBITMQ_DEFAULT_PASS=admin \\</span><br><span class=\"line\">  -v mq-plugins:/plugins \\</span><br><span class=\"line\">  --name mq \\</span><br><span class=\"line\">  -p 15672:15672 \\</span><br><span class=\"line\">  -p 5672:5672 \\</span><br><span class=\"line\">  --network net\\</span><br><span class=\"line\">  -d \\</span><br><span class=\"line\">  rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>\n<p><code>-e RABBITMQ_DEFAULT_USER=admin</code>：RabbitMQ后台管理系统用户名；<br><code>-e RABBITMQ_DEFAULT_PASS=admin</code>：RabbitMQ后台管理系统密码；<br><code>-v mq-plugins:/plugins</code>：挂载数据卷；<br><code>--name mq</code>：容器名；<br><code>-p 15672:15672</code>：RabbitMQ后台管理系统端口；<br><code>-p 5672:5672</code>：RabbitMQ服务端口；<br><code>--network net</code>：指定网络；<br><code>-d</code>：后台运行；<br><code>rabbitmq:3.8-management</code>：镜像名。<br>其他安装方式查看官网。  </p>\n<h3 id=\"2、RabbitMQ后台管理系统使用\"><a href=\"#2、RabbitMQ后台管理系统使用\" class=\"headerlink\" title=\"2、RabbitMQ后台管理系统使用\"></a>2、RabbitMQ后台管理系统使用</h3><p>1、访问地址<br><code>http://ip:15672</code>，输入配置的用户名和密码访问。  </p>\n<p>2、页面介绍<br><code>Connections</code>Tab页：显示消息发送者和消息接收者，只要连接了RabbitMQ的服务都会在这里显示。<br><code>Channels</code>Tab页：显示消息通道。<br><code>Exchanges</code>Tab页：显示交换机。<br><code>Queues</code>Tab页：显示队列。<br><code>Admin</code>Tab页：管理用户。  </p>\n<p>3、RabbitMQ的整体架构和核心概念  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png\" class=\"\">  \n<p>（1）交换机（exchange）只能路由消息，无法存储消息。<br>（2）交换机（exchange）只会路由消息给与自己绑定的队列，因此队列必须与交换机绑定。  </p>\n<p>4、快速入门需求一<br>（1）需求  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class=\"line\"><span class=\"number\">1</span>、新建队列 hello<span class=\"selector-class\">.queue1</span> 和 hello.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、向默认的 amp<span class=\"selector-class\">.fanout</span> 交换机发送一条消息；</span><br><span class=\"line\"><span class=\"number\">3</span>、查看消息是否到达 hello<span class=\"selector-class\">.queue1</span> 和 hello.queue2。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png\" class=\"\">  \n<p>如上图所示，分别添加hello.queue1和hello.queue2两个队列。<br>然后选中<code>Exchanges</code>Tab页，点击<code>amp.fanout</code>交换机进入交换机详情页，将两个队列与交换机建立关联，如下图所示。  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png\" class=\"\">  \n<p>然后在该页面找到<code>Publish message</code>项，在<code>Payload</code>输入hello，mq！，点击发送之后，我们在<code>Queues</code>Tab页查看，两个队列都收到消息了。  </p>\n<p>5、快速入门需求二<br>（1）需求（数据隔离）  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在RabbitMQ的后台管理系统中完成下列操作</span><br><span class=\"line\"><span class=\"number\">1</span>、新建一个用户；</span><br><span class=\"line\"><span class=\"number\">2</span>、为新建的用户创建一个 <span class=\"keyword\">virtual</span> host；</span><br><span class=\"line\"><span class=\"number\">3</span>、测试不同 <span class=\"keyword\">virtual</span> host 之间的数据隔离现象。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤<br>点击<code>Admin</code>Tab页，点击右侧的<code>Users</code>选项，点击<code>Add a user</code>，输入用户名和密码，Tags是用户角色的意思，这里选择超级管理员角色Admin。<br>可以看到刚新建的用户是没有可以访问的virtual host的，退出登录，切换成刚创建的新用户。<br>我们点击<code>Admin</code>Tab页，点击右侧<code>Virtual Hosts</code>选项，点击<code>Add a new virtual host</code>，创建一个新的虚拟机。  </p>\n<h3 id=\"3、Java代码中使用RabbitMQ\"><a href=\"#3、Java代码中使用RabbitMQ\" class=\"headerlink\" title=\"3、Java代码中使用RabbitMQ\"></a>3、Java代码中使用RabbitMQ</h3><h4 id=\"（1）知识介绍\"><a href=\"#（1）知识介绍\" class=\"headerlink\" title=\"（1）知识介绍\"></a>（1）知识介绍</h4><p>演示项目<a href=\"https://gitee.com/zuo-junyuan/microservice-learning-notes\">请点击访问下载</a>，在mq目录<code>mq-demo.zip</code>包。<br><code>AMQP</code>（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准，该协议与语言和平台无关，更符合微服务中独立性的要求。<br><code>Spring AMQP</code>是基于<code>AMQP</code>协议定义的一套API规范，提供了模板来发送和接收消息，它包含两部分，其中<code>spring-amqp</code>是基础抽象，<code>spring-rabbit</code>是底层的默认实现。  </p>\n<h4 id=\"（2）快速入门\"><a href=\"#（2）快速入门\" class=\"headerlink\" title=\"（2）快速入门\"></a>（2）快速入门</h4><p>（1）需求<br>打开上面演示项目，演示项目中包括了两个服务<code>consumer</code>（消息接收者）和<code>publisher</code>（消息发送者）。  </p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、利用RabbitMQ的后台管理系统创建队列 simple.queue；</span><br><span class=\"line\"><span class=\"number\">2</span>、在publisher服务中，利用SpringAMQP直接向simple.queue发送消息；</span><br><span class=\"line\"><span class=\"number\">3</span>、在consumer服务中，利用SpringAMQP编写消费者，监听simple.queue队列。</span><br><span class=\"line\">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>\n<p>（2）步骤<br>创建队列这里不再做阐述。<br>在父工程中引入<code>spring-amqp</code>依赖，这样publisher和consumer两个服务都可以使用：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在每个服务中配置MQ的服务端信息，这样每个服务才能连接到RabbitMQ：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"comment\"># RabbitMQ的部署ip地址</span></span><br><span class=\"line\">\t<span class=\"attr\">port:</span> <span class=\"number\">5672</span> <span class=\"comment\"># RabbitMQ的服务端口</span></span><br><span class=\"line\">\t<span class=\"attr\">virtual-host:</span> <span class=\"string\">/mq</span> <span class=\"comment\"># 要使用的虚拟机</span></span><br><span class=\"line\">\t<span class=\"attr\">username:</span> <span class=\"string\">admin</span> <span class=\"comment\"># 连接到RabbitMQ的用户名</span></span><br><span class=\"line\">\t<span class=\"attr\">password:</span> <span class=\"string\">admin</span> <span class=\"comment\"># 连接到RabbitMQ的密码</span></span><br></pre></td></tr></table></figure>\n<p>在<code>test/java</code>目录下创建<code>com.itheima.publisher</code>单元测试包（单元测试路径要与main包下的路径保持一致），创建<code>SpringAmqpTest</code>测试类，编写测试代码：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringAmqpTest</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 需要使用到RabbitTemplate类，这个类amqp包中已经提供了，可以直接注入使用</span></span><br><span class=\"line\"><span class=\"comment\">\t * RabbitTemplate是SpringAMQP提供的用于操作RabbitMQ的工具类</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSimpleQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1、发送消息</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 第一个参数：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 第二个参数：发送消息的内容</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;simple.queue&quot;</span>,<span class=\"string\">&quot;hello, spring amqp!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动之后，可以去RabbitMQ管理后台查看对应的队列中是否收到消息。<br>在<code>consumer</code>服务中编写监听消息的消息接收者，在main&#x2F;java目录下创建mq包，在mq包下新建SpringRabbitListener监听类：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringRabbitListener</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 监听simple.queue队列的消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> msg 消息内容，发送的时候是什么类型，接收的时候就是什么类型</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenSimpleQueue</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;spring amqp 监听到了simple.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动<code>consumer</code>服务，可以看到控制台输出了消息。现在只要<code>publisher</code>服务那边发送了消息，<code>consumer</code>服务这边就会监听到消息，并且输出收到的消息。  </p>\n<h4 id=\"（3）Work-Queues\"><a href=\"#（3）Work-Queues\" class=\"headerlink\" title=\"（3）Work Queues\"></a>（3）Work Queues</h4><p><code>Work Queues</code>：任务模型，简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。注意：队列中的消息只能由这些消费者中的一个接收，比如：队列中有一条消息，这个队列绑定了三个消费者，队列中的这条消息假如被消费者2接收到了，那么消费者1和消费者3是接收不到的。<br>1、需求  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在RabbitMQ后台管理系统中创建一个队列，名为 work.queue；</span><br><span class=\"line\"><span class=\"number\">2</span>、在 publisher 服务中定义测试方法，发送<span class=\"number\">50</span>条消息到 work.queue；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中定义两个消息监听者，都监听 work.queue 队列。</span><br><span class=\"line\">注意：该需求不涉及交换机，是直接将消息发送到队列。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>基于<code>快速入门</code>中的项目继续做。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenWorkQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenWorkQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了work.queue的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testWorkQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列名</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">queueName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;work.queue&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送50条消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;i &lt;= <span class=\"number\">50</span>;i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 消息内容</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello, spring amqp! &quot;</span> + i;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t\trabbitTemplate.convertAndSend(queueName, msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启两个服务，可以看到<code>consumer</code>服务的控制台输出，两个消费者分别接收到了25条消息。<br>如果这两个消费者是在两个不同的服务中，消费者1的性能要比消费者2的性能好，这种情况下依然是每个消费者都处理25条。<br>那么我们想实现“能者多劳”的效果，也就是说让消费者1处理更多的消息，可以在配置文件中配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">prefetch:</span> <span class=\"number\">1</span> <span class=\"comment\"># 每次只能获取一条消息，处理完成才能获取下一条消息</span></span><br></pre></td></tr></table></figure>\n<p>3、总结：<code>Work</code>模型的使用  </p>\n<ol>\n<li>多个消费者绑定到一个队列，可以加快消息处理速度；  </li>\n<li>同一条消息只会被一个消费者处理；  </li>\n<li>通过设置<code>prefetch</code>来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳。</li>\n</ol>\n<h4 id=\"（4）Fanout交换机\"><a href=\"#（4）Fanout交换机\" class=\"headerlink\" title=\"（4）Fanout交换机\"></a>（4）Fanout交换机</h4><p>上面的案例都没有涉及到<code>交换机</code>，从上面的案例可以看出，消息可以直接发送到队列，队列还具有存储消息的功能，而交换机并没有存储消息的功能，只有路由消息的功能，那为什么还要有交换机呢？<br>我们可以从<code>Work Queues</code>案例看出，队列中的消息只要被消费者接收之后，就没有该条消息了。那么如果想实现这么一个场景：这条消息想要被所有消费者都接收到（广播的模式），该怎么去实现？这就得用到<code>Fanout</code>类型的交换机了。<br><code>交换机</code>的作用：主要是接收发送者发送的消息，并将消息路由到与其绑定的队列，而<code>Fanout交换机</code>就是可以实现一条消息，所有消费者都能接收到，即<code>广播模式</code>。<br>1、需求  </p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在<span class=\"type\">RabbitMQ</span>后台管理系统中，创建两个队列 fanout.queue1 和 fanout.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、在<span class=\"type\">RabbitMQ</span>后台管理系统中，创建交换机 fanout.exchange，类型<span class=\"keyword\">type</span>为 fanout，并将两个队列与其绑定；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2；</span><br><span class=\"line\"><span class=\"number\">4</span>、在 publisher 服务中，编写测试方法，向 fanout.exchange发送消息。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenFanoutQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了fanout.queue1的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenFanoutQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了fanout.queue2的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFanoutExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交换机名称</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">exchangeName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;fanout.exchange&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：这里为null和&quot;&quot;都行</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;hello,exange fanout!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）Direct交换机\"><a href=\"#（5）Direct交换机\" class=\"headerlink\" title=\"（5）Direct交换机\"></a>（5）Direct交换机</h4><p>有这么个场景：想要实现有些消息是多个消费者接收到，有些消息只有个别消费者收到，这种情况下，就需要用到<code>Direct交换机</code>了。<br><code>Direct交换机</code>：会将接收到的消息根据规则路由到指定的队列，即<code>定向模式</code>。<br>（1）每一个队列在与交换机绑定时，都设置一个key（一般将这个key叫做<code>BindingKey</code>）；<br>（2）发送者发送消息时，指定消息的key（一般将这个key叫做<code>RoutingKey</code>）；<br>（3）交换机将消息路由到<code>BindingKey</code>与<code>RoutingKey</code>一致的队列。<br>1、需求  </p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、在RabbitMQ后台管理系统中，创建两个队列 <span class=\"built_in\">direct</span>.queue1 和 <span class=\"built_in\">direct</span>.queue2；</span><br><span class=\"line\"><span class=\"number\">2</span>、在RabbitMQ后台管理系统中，创建交换机 <span class=\"built_in\">direct</span>.exchange，类型type为 <span class=\"built_in\">direct</span>，并将两个队列与其绑定，绑定的时候在RoutingKey输入框处<span class=\"built_in\">direct</span>.queue1指定red、blue两个<span class=\"built_in\">key</span>，也就是BindingKey（输入的时候只能一个一个的输入去绑定），<span class=\"built_in\">direct</span>.queue2指定red、yellow两个<span class=\"built_in\">key</span>；</span><br><span class=\"line\"><span class=\"number\">3</span>、在 consumer 服务中，编写两个消费者方法，分别监听 <span class=\"built_in\">direct</span>.queue1 和 <span class=\"built_in\">direct</span>.queue2；</span><br><span class=\"line\"><span class=\"number\">4</span>、在 publisher 服务中，编写测试方法，向 <span class=\"built_in\">direct</span>.exchange发送消息，并指定RoutingKey。</span><br></pre></td></tr></table></figure>\n<p>2、步骤<br>创建队列这里不再做阐述。<br>（1）在<code>consumer</code>服务中的SpringRabbitListener类中添加两个方法（注意：实际项目中不可能写两个方法）：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueOne</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者1监听到了direct.queue1的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueTwo</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消费者2监听到了direct.queue2的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）在<code>publisher</code>服务中的SpringAmqpTest测试类中添加测试的发送方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDirectExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交换机名称</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">exchangeName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;direct.exchange&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：RoutingKey</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;hello,exange direct!&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 说明：</span></span><br><span class=\"line\"><span class=\"comment\">\t * 1、如果第二个参数RoutingKey为red，那么direct.queue1和direct.queue2都能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 2、如果第二个参数RoutingKey为blue，那么只有direct.queue1能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 3、如果第二个参数RoutingKey为yellow，那么只有direct.queue2能接收到消息；</span></span><br><span class=\"line\"><span class=\"comment\">\t * 4、如果第二个参数RoutingKey为green，那么direct.queue1和direct.queue2都不能接收到消息。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（6）Topic交换机\"><a href=\"#（6）Topic交换机\" class=\"headerlink\" title=\"（6）Topic交换机\"></a>（6）Topic交换机</h4><p><code>Topic交换机</code>：也是基于RoutingKey做消息路由的，但是它的RoutingKey通常是多个单词的组合，并且以<code>.</code>分隔，即<code>主题模式</code>。<br>队列与交换机指定BindingKey时可以使用通配符：<code>#</code>（0个或多个单词）、<code>*</code>（一个单词）。<br>比如：<br>六个队列与一个交换机绑定时，设置的<code>BindingKey</code>为：<br>队列1为<code>china.news</code>：指中国的新闻消息；<br>队列2为<code>china.weather</code>：指中国的天气消息；<br>队列3为<code>japan.news</code>：指日本的新闻消息；<br>队列4为<code>japan.weather</code>：指日本的天气消息；<br>队列5为<code>china.#</code>：指中国的所有消息；<br>队列6为<code>#.news</code>：指所有的新闻消息。<br>然后发送者发送消息指定的<code>RoutingKey</code>为：<br><code>china.#</code>：所有<code>BindingKey</code>中有<code>china</code>的消费者都收到消息，队列1、队列2、队列5收到消息；<br><code>japan.*</code>：只有<code>BindingKey</code>中有<code>japan</code>后跟一个单词的消费者能接收到消息，队列3、队列4收到消息（<code>japan</code>和<code>japan.xxx.xxx</code>是接收不到消息的）；<br><code>#.weather</code>：只有<code>BindingKey</code>中有<code>weather</code>的消费者能接收到消息，队列2、队列4收到消息；<br><code>china.news</code>：只有<code>BindingKey</code>中有<code>china.news</code>的消费者能接收到消息，队列1、队列5、队列6收到消息；<br><code>china.weather</code>：队列2、队列5收到消息。<br>注意：在创建交换机的时候，类型type为<code>topic</code>。  </p>\n<h4 id=\"（7）在代码中声明队列、交换机\"><a href=\"#（7）在代码中声明队列、交换机\" class=\"headerlink\" title=\"（7）在代码中声明队列、交换机\"></a>（7）在代码中声明队列、交换机</h4><p>1、说明<br>之前所有案例的交换机、队列都是在RabbitMQ的后台管理系统中创建的，实际开发中是不允许这么做，都是在代码中创建的。<br><code>SpringAMQP</code>提供了几个类，用来声明队列、交换机及其绑定关系：<br>（1）<code>Queue</code>：用于声明队列，可以用工厂类<code>QueueBuilder</code>构建；<br>（2）<code>Exchange</code>：用于声明交换机，可以用工厂类<code>ExchangeBuilder</code>构建；<br>（3）<code>Binding</code>：用于声明队列和交换机的绑定关系，可以用工厂类<code>BindingBuilder</code>构建。  </p>\n<p>2、使用配置类声明<br>声明一个<code>Fanout</code>类型的交换机，并且创建队列与其绑定：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FanoutConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明 FanoutExchange 交换机</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> FanoutExchange <span class=\"title function_\">fanoutExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 参数：交换机的名称</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanout.exchange&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明第一个队列</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">fanoutQueueOne</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 参数：队列的名称</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;fanout.queue1&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定队列1和交换机</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">bindingQueueOne</span><span class=\"params\">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 绑定哪个队列到哪个交换机</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果有 BindingKey 在to方法后面调用with方法指定，如果得指定多个 BindingKey 就得再新建一个方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...略，同理，以相同的方式声明第二个队列并完成绑定</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 同一个队列指定多个 BindingKey：</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@Bean</span></span></span><br><span class=\"line\"><span class=\"comment\">\t * public Binding bindingQueueOneRed(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t *   // 指定 第一个 BindingKey 为 Red</span></span><br><span class=\"line\"><span class=\"comment\">\t *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;red&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Bean</span></span></span><br><span class=\"line\"><span class=\"comment\">\t * public Binding bindingQueueOneBlue(Queue fanoutQueueOne, FanoutExchange fanoutExchange) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t *   // 指定 第二个 BindingKey 为 Blue</span></span><br><span class=\"line\"><span class=\"comment\">\t *   return BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange).with(&quot;blue&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用工厂类来创建队列、交换机及其绑定关系：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FanoutConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明 FanoutExchange 交换机</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> FanoutExchange <span class=\"title function_\">fanoutExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ExchangeBuilder.fanoutExchange(<span class=\"string\">&quot;fanout.exchange&quot;</span>).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 声明第一个队列</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">fanoutQueueOne</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;fanout.queue1&quot;</span>).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 绑定队列1和交换机</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; Queue fanoutQueueOne 要和上面声明第一个队列方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> &#123;Object&#125; FanoutExchange fanoutExchange 要和上面声明交换机方法名称保持一致</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">bindingQueueOne</span><span class=\"params\">(Queue fanoutQueueOne, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 绑定哪个队列到哪个交换机</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 指定多个 BindingKey 同上面的方式一样</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueueOne).to(fanoutExchange);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：上面的配置类都是写在<code>consumer</code>消费者服务中的！<br>为什么？<br>因为发送者只关心发送消息，将消息发到交换机或队列就行了，而消费者需要去监听队列，需要知道队列和哪个交换机绑定了。<br>上面绑定多个BindingKey方法太繁琐，推荐使用注解方式。  </p>\n<p>3、使用注解方式声明<br><code>SpringAMQP</code>还提供了基于<code>@RabbitListener</code>注解来声明队列和交换机：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(</span></span><br><span class=\"line\"><span class=\"meta\">  bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">\texchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">\tkey = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">  )</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDirectQueueOne</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;消费者1收到消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：上面的注解方式也是写在<code>consumer</code>消费者服务中的，这个注解是使用在需要监听队列的方法上的！  </p>\n<h4 id=\"（8）消息转换器\"><a href=\"#（8）消息转换器\" class=\"headerlink\" title=\"（8）消息转换器\"></a>（8）消息转换器</h4><p>1、说明<br><code>SpringAMQP</code>中默认消息是网络传输，将消息内容（对象）转化成字节，通过字节流进行传输，默认的消息转换器是<code>SimpleMessageConverter</code>实现类，基于JDK的<code>ObjectOutputStream</code>完成序列化。<br>它存在下列问题：<br>（1）JDK的序列化有完全风险；<br>（2）JDK序列化的消息太大；<br>（3）JDK序列化的消息可读性差，是一串乱码。  </p>\n<p>2、修改默认消息转换器<br>推荐使用JSON序列化代替默认的JDK序列化，在publisher和consumer服务中引入jackson依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在publisher和consumer服务中配置MessageConverter消息转换器：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MessageConverter <span class=\"title function_\">messageConverter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonMessageConverter</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（9）消息队列在实际项目中的运用\"><a href=\"#（9）消息队列在实际项目中的运用\" class=\"headerlink\" title=\"（9）消息队列在实际项目中的运用\"></a>（9）消息队列在实际项目中的运用</h4><p>具体查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-53\">SpringCloud学习笔记第五、其他问题消息队列的使用</a>。  </p>\n<h3 id=\"4、使用过程中遇到的问题\"><a href=\"#4、使用过程中遇到的问题\" class=\"headerlink\" title=\"4、使用过程中遇到的问题\"></a>4、使用过程中遇到的问题</h3><h4 id=\"（1）确保消息发送成功\"><a href=\"#（1）确保消息发送成功\" class=\"headerlink\" title=\"（1）确保消息发送成功\"></a>（1）确保消息发送成功</h4><p>1、发送者重连机制（针对消息发送者）<br>场景：假如MQ消息队列服务挂了或者由于网络波动，可能会出现发送者连接MQ失败的情况。<br>在消息发送服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">connection-timeout:</span> <span class=\"string\">1s</span> <span class=\"comment\"># 设置MQ的连接超时时间，例如：等了1s还没连上就认为连接超时</span></span><br><span class=\"line\">\t<span class=\"attr\">template:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">retry:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启超时重试机制，默认是没有开启</span></span><br><span class=\"line\">\t\t<span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span> <span class=\"comment\"># 重连失败后的初始等待时间，例如：连接超时之后不会立刻去重连，会等待1000ms再去重连</span></span><br><span class=\"line\">\t\t<span class=\"attr\">multiplier:</span> <span class=\"number\">1</span> <span class=\"comment\"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier，例如：如果设置为2，第一次等待1000ms（因为初始等待时间设置的是1000ms），第二次等待2000ms，第三次4000ms</span></span><br><span class=\"line\">\t\t<span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span> <span class=\"comment\"># 最大重连次数</span></span><br></pre></td></tr></table></figure>\n<p>注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率，不过SpringAMQP提供的重试机制是阻塞式的重试，也即是说在重试期间，发送消息服务会一直在重试，直到重试成功或者达到重试最大次数，才会继续往下执行业务，会影响业务性能。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，也可以考虑使用异步线程来执行发送消息的代码。  </p>\n<p>2、发送者确认机制（针对消息发送者）<br>SpringAMQP有<code>Publisher Confirm</code>和<code>Publisher Return</code>两种确认机制（是一起使用的）。开启确认机制后，当发送消息服务给MQ发送消息后，MQ会返回确认结果给发送消息服务，返回结果有以下几种情况：<br>（1）消息投递到了MQ，但是路由失败（没有绑定队列或者代码错误）。此时会通过PublisherReturn返回路由异常原因，然后返回ACK（确认结果），告知消息投递成功；<br>（2）临时消息（不需要持久化的消息）投递到了MQ，并且入队成功，返回ACK，告知投递成功；<br>（3）持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功；<br>（4）其他情况都会返回NACK，告知投递失败。<br>一般收到NACK都需要重发消息，收到ACK的记录日志。<br>在发送消息服务的配置文件中配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"comment\"># publisher-confirm-type有三种模式：</span></span><br><span class=\"line\">\t<span class=\"comment\"># 1. none：关闭confirm机制，默认</span></span><br><span class=\"line\">\t<span class=\"comment\"># 2. simple：同步阻塞等待MQ的回执消息</span></span><br><span class=\"line\">\t<span class=\"comment\"># 3. correlated：MQ异步回调方式返回回执消息</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span> <span class=\"comment\"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class=\"line\">\t<span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启publisher return机制，默认为false</span></span><br></pre></td></tr></table></figure>\n<p>配置<code>Publisher Return</code>，创建一个MQ配置类：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MQConfig</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置Publisher Return回调函数</span></span><br><span class=\"line\">\t\trabbitTemplate.setReturnsCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(ReturnedMessage returned)</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;交换机为：&quot;</span> + returned.getExchange());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;routingKey：&quot;</span> + returned.getRoutingKey());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息本身message：&quot;</span> + returned.getMessage());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;异常code：&quot;</span> + returned.getReplyCode());</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;异常message：&quot;</span> + returned.getReplyText());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后配置<code>Publisher Confirm</code>，需要去发送消息的代码处修改：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改之前的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSendMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange.direct&quot;</span>, <span class=\"string\">&quot;发送的消息内容&quot;</span>, <span class=\"string\">&quot;hello direct&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改之后的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSendMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置Publisher Confirm回调函数</span></span><br><span class=\"line\">\t<span class=\"type\">CorrelationData</span> <span class=\"variable\">cd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class=\"line\">\tcd.getFuture().addCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSuccess</span><span class=\"params\">(CorrelationData.Confirm result)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (result.isAck()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息投递成功&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;消息投递失败&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 这里springamqp 内部处理时出现的异常，不是mq投递消息失败的异常</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 一般是不会出现的</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onFailure</span><span class=\"params\">(Throwable ex)</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;spring amqp 处理确认结果异常：&quot;</span> + ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange.direct&quot;</span>, <span class=\"string\">&quot;发送的消息内容&quot;</span>, <span class=\"string\">&quot;hello direct&quot;</span>, cd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"（2）确保MQ的可靠性\"><a href=\"#（2）确保MQ的可靠性\" class=\"headerlink\" title=\"（2）确保MQ的可靠性\"></a>（2）确保MQ的可靠性</h4><p>在默认情况下，RabbitMQ会将收到的消息保存在内存中，以降低消息收发的延迟，这样会导致两个问题：  </p>\n<ul>\n<li>一旦MQ宕机，内存中的消息会丢失；  </li>\n<li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞。</li>\n</ul>\n<p>因此可以使用<code>数据持久化</code>和<code>Lazy Queue</code>来确保MQ的可靠性。<br>推荐使用<code>Lazy Queue</code>。  </p>\n<p>1、数据持久化<br>RabbitMQ实现数据持久化包括3个方面（每个都要做，下面三个都设置之后，哪怕MQ服务重启都不会丢失消息）：  </p>\n<ul>\n<li>交换机持久化；<br>在RabbitMQ后台管理系统中，创建交换机时，在<code>Durability</code>选项处选择<code>Durable</code>，代表交换机持久化；而<code>Transient</code>代表临时数据。  </li>\n<li>队列持久化，同交换机持久化一样的操作；  </li>\n<li>消息持久化。<br>在RabbitMQ后台管理系统中，发送消息时，有个<code>Delivery mode</code>选项，<code>Non-persistent</code>代表临时消息；<code>Persistent</code>代表持久化消息。</li>\n</ul>\n<p>使用代码测试：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个测试，是用来测试消息设置成持久化之前和之后的性能对比。</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：测试之前，需要先创建好持久交换机、队列，</span></span><br><span class=\"line\"><span class=\"comment\"> * 并且将配置文件中的关于确保消息发送成功的相关配置关闭</span></span><br><span class=\"line\"><span class=\"comment\"> * 步骤：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1、将下面message先设置成临时消息，测试一次；</span></span><br><span class=\"line\"><span class=\"comment\"> * 2、再将message设置成持久化消息，测试一次；</span></span><br><span class=\"line\"><span class=\"comment\"> * 3、可以查看RabbitMQ后台管理系统的消息积压情况，可知将message设置成持久化之后，性能会更好。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testSendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 这里因为涉及到消息持久化，所以我们需要自定义构建消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * 使用MessageBuilder消息工厂类自定义消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * withBody()方法：设置消息体，因为它需要字节码，所以这里需要将字符串转换为字节码</span></span><br><span class=\"line\"><span class=\"comment\">\t * setDeliveryMode()方法：设置消息的投递模式，默认是Non-persistent，也就是临时消息</span></span><br><span class=\"line\"><span class=\"comment\">\t * PERSISTENT代表持久化消息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> MessageBuilder.withBody(<span class=\"string\">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class=\"line\">\t\t\t.setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class=\"line\">\t\t\t.build();</span><br><span class=\"line\">\t<span class=\"comment\">// 发送1000000条消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; <span class=\"number\">1000000</span>;i ++) &#123;</span><br><span class=\"line\">\t\trabbitTemplate.convertAndSend(<span class=\"string\">&quot;交换机名字&quot;</span>, message);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、Lazy Queue（直接将消息存入磁盘，不存内存）<br>之前的版本是先将消息存到内存中，然后再根据消息设置，如果设置了消息为持久化，才将消息存入磁盘。而从RabbitMQ的3.6.0版本开始，就增加了Lazy Queue的概念，也就是惰性队列，它的特征是：  </p>\n<ul>\n<li>接收到消息后直接存入磁盘，不再存储到内存；  </li>\n<li>消费者要消费消息时，才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）。</li>\n</ul>\n<p>也就是说不管消息是临时消息还是持久化消息，直接存入磁盘，不存内存，等消费者要使用消息时，再从磁盘存入内存。<br>注意：在3.12版本后，所有队列都是Lazy Queue模式，无法更改。<br>如果使用3.12之前的版本，需要使用Lazy Queue的话，在RabbitMQ后台管理系统中创建队列的时候，需要在<code>Arguments</code>选项处添加<code>x-queue-mode=lazy</code>参数，这里不需要在输入框输入，可以直接点击下面的<code>Lazy mode</code>即可添加。<br>使用代码的方式添加：<br>要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为lazy即可。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">lazyQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;队列名字&quot;</span>)</span><br><span class=\"line\">\t                   .lazy() <span class=\"comment\">// 开启lazy模式</span></span><br><span class=\"line\">\t\t\t\t\t   .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注解方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class=\"line\"><span class=\"meta\">  name = &quot;队列名字&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">  durable = &quot;true&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">  arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenLazyQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;LazyQueue接收到消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>推荐使用时，都使用这个方式！！！！<br>总结：<br>（1）首先通过配置可以让交换机、队列、以及发送的消息都持久化。这样队列中的消息会持久化到磁盘，MQ重启，消息依然存在；<br>（2）RabbitMQ在3.6版本引入了LazyQueue，并且在3.12版本后会将其设置成队列的默认模式，这个模式会将所有消息都持久化；<br>（3）开启持久化和生产者确认时，RabbitMQ只有在消息持久化完成后才会给生产者返回ACK回执。  </p>\n<h4 id=\"（3）确保消息接收成功\"><a href=\"#（3）确保消息接收成功\" class=\"headerlink\" title=\"（3）确保消息接收成功\"></a>（3）确保消息接收成功</h4><p>1、消费者确认机制（针对消息接收服务）<br>消费者确认机制是为了确认消费者是否成功处理消息，一共有三种场景：  </p>\n<ul>\n<li>返回<code>ACK</code>：表示消费者成功处理消息之后，返回ACK给MQ服务，告知MQ服务自己成功处理消息，让MQ服务将该消息从队列中删除；  </li>\n<li>返回<code>NACK</code>：表示消费者处理消息时出现异常，返回NACK给MQ服务，告知MQ服务不要删除消息，将消息重新投递给自己处理，直到成功；  </li>\n<li>返回<code>REJECT</code>：表示消费者处理消息时出现异常，并告知MQ服务，拒绝该消息处理，让MQ服务将该消息从队列中删除。</li>\n</ul>\n<p>注意：上面的三种场景都是消费者处理完之后才能返回，不是刚接收到消息就返回。<br>因为SpringAMQP已经实现了消息确认功能，所以只需要在配置文件中配置处理方式，有三种方式：  </p>\n<ul>\n<li>none：不处理，即消息投递给消费者后，不管消息是否处理成功，MQ服务都会将消息从队列中删除（默认方式）；  </li>\n<li>manual：手动模式，需要自己在业务代码中调用api，发送ACK或REJECT，这种方式可能存在业务入侵；  </li>\n<li>auto：自动模式，SpringAMQP利用AOP实现了功能，自动返回不同的结果。</li>\n</ul>\n<p>在消息接收服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span></span><br><span class=\"line\">\t    <span class=\"attr\">acknowledge-mode:</span> <span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n<p>针对上面消费者确认机制中的第二种场景，返回NACK，如果消费者（即消息接收服务）一直处理失败，MQ服务就会一直投递，这是不可取的，会让MQ服务有很大压力，所以我们还需要设置<code>失败重试机制</code>。<br>在消息接收服务配置：  </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span> </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span> </span><br><span class=\"line\">    <span class=\"attr\">listener:</span> </span><br><span class=\"line\">\t  <span class=\"attr\">simple:</span> </span><br><span class=\"line\">\t    <span class=\"attr\">retry:</span> </span><br><span class=\"line\">\t\t  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 开启消费者失败重试，默认时关闭的</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span> <span class=\"comment\"># 初始的失败等待时长为1s</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">multiplier:</span> <span class=\"number\">1</span> <span class=\"comment\"># 下次失败的等待时长倍数，下次等待时长 = multiplier * initial-interval</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span> <span class=\"comment\"># 最大重试次数</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">stateless:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 是否无状态，true无状态，false有状态，如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>\n<p>注意：<br>（1）如果<code>stateless</code>设置为false，表示有事务，那么<code>max-attempts</code>属性将失效，因为涉及到事务，所以不能重试；<br>（2）如果<code>stateless</code>设置为true，表示无事务，那么<code>max-attempts</code>属性生效，可以重试。<br>这里介绍下重试策略：<br>在开启重试模式后，重试次数耗尽，如果消息依然存在，则需要有<code>MessageRecoverer</code>接口来处理，它有三种不同实现：  </p>\n<ul>\n<li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject拒绝消息，丢弃消息，不再重试（默认方式）；  </li>\n<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回NACK，消息重新入队等待消费；  </li>\n<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机。<br>将重试策略修改为<code>RepublishMessageRecoverer</code>，在消息接收服务创建配置类：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ErrorMessageConfig</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建定义交换机</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">errorExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;交换机名字&quot;</span>); <span class=\"comment\">// error.direct</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建定义队列</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Queue <span class=\"title function_\">errorQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;队列名字&quot;</span>); <span class=\"comment\">// error.queue</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 绑定交换机和队列</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Binding <span class=\"title function_\">errorQueueBinding</span><span class=\"params\">(Queue errorQueue, DirectExchange errorExchange)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BindingBuilder.bind(errorQueue)</span><br><span class=\"line\">\t\t                     .to(errorExchange)</span><br><span class=\"line\">\t\t                     .with(<span class=\"string\">&quot;路由键名字&quot;</span>); <span class=\"comment\">// error</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 重试策略</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> MessageRecoverer <span class=\"title function_\">messageRecoverer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// return new RepublishMessageRecoverer(rabbitTemplate, &quot;error.direct&quot;, &quot;error&quot;);</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RepublishMessageRecoverer</span>(rabbitTemplate, <span class=\"string\">&quot;交换机名字&quot;</span>, <span class=\"string\">&quot;路由键名字&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n现在还有这么一个问题，就是消费者重复处理问题，比如消费者处理完消息后，要返回状态给MQ服务，此时因为网络原因，MQ服务没有收到消费者的恢复，MQ服务就会将消息重新投递给消费者，导致消费者重复处理消息。<br>解决方法一：<code>唯一消息id</code><br>给每个消息都设置一个唯一id，利用id区分是否是重复消息：<br>（1）每一条消息都生成一个唯一的id，与消息一起投递给消费者；<br>（2）消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库；<br>（3）如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息，放弃处理。<br>在消息发送服务（消息提供者）修改消息转换器，让消息转换器帮我们生成消息id：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MessageConverter <span class=\"title function_\">messageConverter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">Jackson2JsonMessageConverter</span> <span class=\"variable\">converter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonMessageConverter</span>();</span><br><span class=\"line\">\tconverter.setCreateMessageIds(<span class=\"literal\">true</span>); <span class=\"comment\">// 开启消息id生成</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> converter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n在消息接收服务（消费者）接收消息id：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 之前是消息发送服务发送的是什么类型的消息，消息接收服务接收消息就是什么类型的消息</span></span><br><span class=\"line\"><span class=\"comment\"> * 现在修改为使用Message类来接收消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;queue.name&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveMessage</span><span class=\"params\">(Message message)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取消息id</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">messageId</span> <span class=\"operator\">=</span> message.getMessageProperties().getMessageId();</span><br><span class=\"line\">\t<span class=\"comment\">// 获取消息内容</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(message.getBody());</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消息id：&quot;</span> + messageId);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;消息内容：&quot;</span> + content);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>解决方法二：<code>基于业务判断</code><br>在MQ服务第一次投递给消费者处理之前，先查询数据库，判断消息是否已经处理过，如果处理过则直接返回ACK，不再处理。具体例子查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-54\">SpringCloud学习笔记第五点其他问题的第4点</a>。  </p>\n<h4 id=\"（4）延迟消息\"><a href=\"#（4）延迟消息\" class=\"headerlink\" title=\"（4）延迟消息\"></a>（4）延迟消息</h4><p>1、使用场景<br>保证服务A和服务B一致性，通常是基于消息队列，由服务A通知服务B，去保证一致性。但是因为某个原因，导致这种方案就是不能成功（不能保证一致性），所以此时就必须有一个兜底方案，就是消息延迟。<br>延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。<br>就比如通常情况下，都是服务A通知服务B，延迟消息就是有一个<code>专门接收延迟消息的消息队列</code>，服务A通知服务B的同时，也发一个延迟消息给这个消息队列（设置一个延迟时间，比如15分钟），然后服务A等待服务B回执15分钟，如果15分钟之后还是没有服务B的回执，那服务A就主动去远程查询（调用）服务B。<br>2、实现方式<br>（1）死信交换机<br>（2）延迟消息插件<br>3、<code>死信交换机</code><br>（1）解释<br>当一个队列中的消息满足下列情况之一时，就会成为死信：  </p>\n<ul>\n<li>消费者使用<code>reject</code>或<code>nack</code>返回消费失败，并且消息被设置成不想重新投递（消息的requeue参数设置为false）；  </li>\n<li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费；  </li>\n<li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li>\n</ul>\n<p>默认情况下，消息成为死信会被删除。<br>如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的消息成为死信后，就会投递到被指定的这个交换机中，这个交换机就是<code>死信交换机（DLX）</code>。<br>所以<code>死信交换机</code>：就是专门用来接收死信的交换机。<br>现在使用<code>死信交换机</code>来做<code>延迟消息</code>，下图所示：  </p>\n<img src=\"/2024/12/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png\" class=\"\">  \n<p>注意：如果使用了key，那么死信交换机、死信队列要和上面交换机、队列的key保持一致。<br>（2）代码实现<br>定义一个死信交换机和死信队列：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">  value = @Queue(name = &quot;dlx.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  exchange = @Exchange(name = &quot;dlx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenDlxQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;接收到死信队列的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不能使用上面的方法来定义交换机、队列，因为使用上面的方法就会有消费者监听。需要使用传统的方式定义一个普通交换机、普通队列，并设置死信交换机：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建定义交换机</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">normalExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;normal.direct&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建定义队列，并设置dead-letter-exchange属性，绑定一个死信交换机</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">normalQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;normal.queue&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t .deadLetterExchange(<span class=\"string\">&quot;dlx.direct&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 绑定交换机和队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Binding <span class=\"title function_\">normalExchangeBinding</span><span class=\"params\">(Queue normalQueue, DirectExchange normalExchange)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class=\"string\">&quot;hi&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送消息：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：路由键名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  rabbitTemplate.convertAndSend(<span class=\"string\">&quot;normal.direct&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>, <span class=\"string\">&quot;hello world&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">MessagePostProcessor</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Message <span class=\"title function_\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置消息过期时间10s</span></span><br><span class=\"line\">      message.getMessageProperties().setExpiration(<span class=\"string\">&quot;10000&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、<code>延迟消息插件</code>（DelayExchange插件）<br>因为上面<code>死信交换机</code>实现比较繁琐，需要创建定义多个交换机和队列，容易出错，所以可以使用<code>延迟消息插件</code>。<br>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。<br><a href=\"https://blog.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq#installing-the-plugin\">关于插件下载请点击</a>，插件版本要和MQ版本保持一致，比如MQ是3.8，那么插件也要3.8。<br>（1）安装插件（基于Docker安装）<br>如果MQ是基于Docker安装的，才看这个。<br>先查看RabbitMQ的插件目录对应的数据卷：<code>docker volume inspect mq-plugins</code>，<code>mq-plugins</code>是数据卷的名字，如果挂载的数据卷名字不是这个，需要根据自己的数据卷名字修改，可以使用<code>docker volume ls</code>查看所有数据卷列表。<br>可以看到<code>Mountpoint</code>属性，表示插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，上传下载下来的插件到该目录。<br>然后执行命令，安装插件：<code>docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，<code>-it</code>后面的mq是容器的名字，根据自己的容器名修改。<br>（2）使用<br>通过注解方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// delayed属性设为true，表示是延迟交换机</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">  value = @Queue(name = &quot;队列名字&quot;, durable = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  exchange = @Exchange(name = &quot;交换机名字&quot;, type = ExchangeTypes.DIRECT, delayed = &quot;true&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">  key = &#123;&quot;hi&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listenQueue</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;接收到延迟队列的消息：&quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过代码方式：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">delayExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ExchangeBuilder</span><br><span class=\"line\">\t\t\t.directExchange(<span class=\"string\">&quot;交换机名字&quot;</span>)</span><br><span class=\"line\">\t\t\t.delayed() <span class=\"comment\">// 设置delay属性为true</span></span><br><span class=\"line\">\t\t\t.durable(<span class=\"literal\">true</span>) <span class=\"comment\">// 持久化</span></span><br><span class=\"line\">\t\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送消息是需要通过消息头<code>x-delay</code>来设置过期时间：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第一个参数：交换机名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第二个参数：路由键名字</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第三个参数：消息内容</span></span><br><span class=\"line\"><span class=\"comment\">\t * 第四个参数：MessagePostProcessor是消息后置处理器，可以用来对消息进行处理，比如设置消息过期时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  rabbitTemplate.convertAndSend(<span class=\"string\">&quot;delay.direct&quot;</span>, <span class=\"string\">&quot;hi&quot;</span>, <span class=\"string\">&quot;hello world&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">MessagePostProcessor</span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Message <span class=\"title function_\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置消息过期时间10s</span></span><br><span class=\"line\">      message.getMessageProperties().setDelay(<span class=\"number\">10000</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、具体使用<code>延迟消息插件</code>示例<br>请查看<a href=\"/2024/11/27/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#spring-cloud-55\">SpringCloud学习笔记中其他问题章节的第5点</a>。  </p>\n","categories":[{"name":"工作技能","path":"api/categories/工作技能.json"}],"tags":[{"name":"工作技能","path":"api/tags/工作技能.json"},{"name":"后端","path":"api/tags/后端.json"},{"name":"消息队列","path":"api/tags/消息队列.json"}]}